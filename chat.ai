## SYSTEM:

## USER:

In greger-tools--git-stage-and-commit in greger-stdlib.el, only save and stage the chat file if the chat file is already in version control (don't add it if it's untracked)

## ASSISTANT:

I'll help you modify the `greger-tools--git-stage-and-commit` function in `greger-stdlib.el` to only save and stage the chat file if it's already in version control. Let me first examine the current implementation.

## TOOL USE:

Name: read-file
ID: toolu_013ayqdde6MgzHqjGcpThfss

### path

<tool.toolu_013ayqdde6MgzHqjGcpThfss>
greger-stdlib.el
</tool.toolu_013ayqdde6MgzHqjGcpThfss>

### include_line_numbers

<tool.toolu_013ayqdde6MgzHqjGcpThfss>
true
</tool.toolu_013ayqdde6MgzHqjGcpThfss>

## TOOL RESULT:

ID: toolu_013ayqdde6MgzHqjGcpThfss

<tool.toolu_013ayqdde6MgzHqjGcpThfss>
  1: ;;; greger-stdlib.el --- Tool definitions for greger agent -*- lexical-binding: t -*-
  2:
  3: ;;; Commentary:
  4: ;; Defines tools available to the greger agent
  5:
  6: ;;; Code:
  7:
  8: (require 'greger-tools)
  9: (require 'greger-web)
 10:
 11: ;; Register all tools using the macro
 12: (greger-register-tool "read-file"
 13:   :description "Read the contents of a file from the filesystem"
 14:   :properties '((path . ((type . "string")
 15:                          (description . "Path to the file to read")))
 16:                 (include_line_numbers . ((type . "boolean")
 17:                                          (description . "Whether to include line numbers in the output. If you plan to modify the file, you should include line numbers here so you know which lines to edit.")
 18:                                          (default . nil)))
 19:                 (start_line . ((type . "integer")
 20:                                (description . "Starting line number (1-based) to begin reading from. If not specified, reads from the beginning of the file.")
 21:                                (default . nil)))
 22:                 (end_line . ((type . "integer")
 23:                              (description . "Ending line number (1-based) to stop reading at (inclusive). If not specified, reads to the end of the file.")
 24:                              (default . nil))))
 25:   :required '("path")
 26:   :function 'greger-tools--read-file)
 27:
 28: (greger-register-tool "list-directory"
 29:   :description "List files and directories in a given directory"
 30:   :properties '((path . ((type . "string")
 31:                          (description . "Path to the directory to list. Defaults to current directory.")
 32:                          (default . ".")))
 33:                 (show-hidden . ((type . "boolean")
 34:                                 (description . "Whether to show hidden files starting with .")
 35:                                 (default . nil)))
 36:                 (recursive . ((type . "boolean")
 37:                               (description . "Whether to list files recursively")
 38:                               (default . nil))))
 39:   :required '()
 40:   :function 'greger-tools--list-directory)
 41:
 42: (greger-register-tool "ripgrep"
 43:   :description "Search for patterns in files using ripgrep (rg) command line tool. Note that ripgrep only matches on single lines, so you can't search across multiple lines."
 44:   :properties '((pattern . ((type . "string")
 45:                             (description . "The search pattern (regex or literal string)")))
 46:                 (path . ((type . "string")
 47:                          (description . "Directory or file path to search in")
 48:                          (default . ".")))
 49:                 (case-sensitive . ((type . "boolean")
 50:                                    (description . "Whether the search should be case-sensitive")
 51:                                    (default . nil)))
 52:                 (file-type . ((type . "string")
 53:                               (description . "Restrict search to specific file types (e.g., 'py', 'js', 'md')")))
 54:                 (context-lines . ((type . "integer")
 55:                                   (description . "Number of context lines to show around matches")
 56:                                   (default . 0)))
 57:                 (max-results . ((type . "integer")
 58:                                 (description . "Maximum number of results to return")
 59:                                 (default . 50))))
 60:   :required '("pattern")
 61:   :function 'greger-tools--ripgrep)
 62:
 63: (greger-register-tool "write-new-file"
 64:   :description "Write a new file with the given contents. Fails if the file already exists."
 65:   :properties '((file_path . ((type . "string")
 66:                               (description . "Absolute path to the new file")))
 67:                 (contents . ((type . "string")
 68:                              (description . "Contents to write to the new file")))
 69:                 (git_commit_message . ((type . "string")
 70:                                        (description . "Git commit message for this change"))))
 71:   :required '("file_path" "contents" "git_commit_message")
 72:   :function 'greger-tools--write-new-file
 73:   :pass-buffer t)
 74:
 75: (greger-register-tool "make-directory"
 76:   :description "Recursively create a directory and all parent directories if they don't exist"
 77:   :properties '((path . ((type . "string")
 78:                          (description . "Path to the directory to create")))
 79:                 (git_commit_message . ((type . "string")
 80:                                        (description . "Git commit message for this change"))))
 81:   :required '("path" "git_commit_message")
 82:   :function 'greger-tools--make-directory
 83:   :pass-buffer t)
 84:
 85: (greger-register-tool "rename-file"
 86:   :description "Rename or move a file from one path to another"
 87:   :properties '((old_path . ((type . "string")
 88:                              (description . "Current path of the file")))
 89:                 (new_path . ((type . "string")
 90:                              (description . "New path for the file")))
 91:                 (git_commit_message . ((type . "string")
 92:                                        (description . "Git commit message for this change"))))
 93:   :required '("old_path" "new_path" "git_commit_message")
 94:   :function 'greger-tools--rename-file
 95:   :pass-buffer t)
 96:
 97: (greger-register-tool "replace-function"
 98:   :description "Replace a function in a Python or Elisp file with new contents. Fast and reliable - only supports 'def function_name' and '(defun function_name ())' forms. Use replace-file for complete file replacement or str-replace for other specific changes."
 99:   :properties '((file_path . ((type . "string")
100:                               (description . "Path to the file containing the function")))
101:                 (function_name . ((type . "string")
102:                                   (description . "Name of the function to replace")))
103:                 (contents . ((type . "string")
104:                              (description . "New function contents to replace the existing function")))
105:                 (line_number . ((type . "integer")
106:                                 (description . "Line number where the function is defined")))
107:                 (commit_message . ((type . "string")
108:                                    (description . "Git commit message for this change"))))
109:   :required '("file_path" "function_name" "contents" "line_number" "commit_message")
110:   :function 'greger-tools--replace-function
111:   :pass-buffer t)
112:
113: (greger-register-tool "replace-file"
114:   :description "Replace the entire contents of an existing file. Slow but reliable - replaces the complete file contents. Use str-replace for specific changes in large files, or replace-function for Python/Elisp functions."
115:   :properties '((file_path . ((type . "string")
116:                               (description . "Path to the file to replace")))
117:                 (contents . ((type . "string")
118:                              (description . "New contents to replace the entire file")))
119:                 (git_commit_message . ((type . "string")
120:                                        (description . "Git commit message for this change"))))
121:   :required '("file_path" "contents" "git_commit_message")
122:   :function 'greger-tools--replace-file
123:   :pass-buffer t)
124:
125: (greger-register-tool "str-replace"
126:   :description "Replace a specific string or content block in a file with new content. Finds the exact original content and replaces it with new content. Be extra careful to format the original_content exactly correctly, taking extra care with whitespace and newlines. If you're making large swaths of changes, consider using replace-file instead"
127:   :properties '((file_path . ((type . "string")
128:                               (description . "Path to the file to modify")))
129:                 (original_content . ((type . "string")
130:                                      (description . "The exact content to find and replace")))
131:                 (new_content . ((type . "string")
132:                                 (description . "The new content to replace the original content with")))
133:                 (git_commit_message . ((type . "string")
134:                                        (description . "Git commit message for this change"))))
135:   :required '("file_path" "original_content" "new_content" "git_commit_message")
136:   :function 'greger-tools--str-replace
137:   :pass-buffer t)
138:
139: (greger-register-tool "insert"
140:   :description "Insert text at a specific line number in a file. The text will be inserted before the specified line number (use 0 to insert at the beginning of the file, 1 to insert before the first line, etc.). Useful for adding new content, comments, or code blocks at precise locations without replacing existing content."
141:   :properties '((file_path . ((type . "string")
142:                               (description . "Path to the file to modify")))
143:                 (line_number . ((type . "integer")
144:                                 (description . "Line number before which to insert the content (0 for beginning of file, 1 to insert before first line, etc.)")))
145:                 (content . ((type . "string")
146:                             (description . "Content to insert at the specified location")))
147:                 (git_commit_message . ((type . "string")
148:                                        (description . "Git commit message for this change"))))
149:   :required '("file_path" "line_number" "content" "git_commit_message")
150:   :function 'greger-tools--insert
151:   :pass-buffer t)
152:
153: (greger-register-tool "git-log"
154:   :description "View git commit logs."
155:   :properties '((path . ((type . "string")
156:                          (description . "Path to the git repository or any file in the repository view logs for")
157:                          (default . ".")))
158:                 (max_rows . ((type . "integer")
159:                             (description . "Maximum number of log entries to return")
160:                             (default . 100))))
161:   :required '()
162:   :function 'greger-tools--git-log)
163:
164: (greger-register-tool "git-show-commit"
165:   :description "View a specific git commit."
166:   :properties '((commit_hash . ((type . "string")
167:                                 (description . "The commit hash to view")))
168:                 (path . ((type . "string")
169:                          (description . "Path to the git repository or any file in the repository")
170:                          (default . "."))))
171:   :required '("commit_hash")
172:   :function 'greger-tools--git-show-commit)
173:
174: (greger-register-tool "ert-test"
175:   :description "Execute ERT tests by evaluating Emacs lisp test functions and running them with ert"
176:   :properties '((test_file_path . ((type . "string")
177:                                    (description . "Path to the test file containing ERT tests")))
178:                 (function_names . ((type . "array")
179:                                    (items . ((type . "string")))
180:                                    (description . "List of ERT test function names to evaluate and run"))))
181:   :required '("test_file_path" "function_names")
182:   :function 'greger-tools--ert-test)
183:
184: (greger-register-tool "eval-elisp-defuns"
185:   :description "Evaluate Emacs lisp defuns in a specific file. Note that defuns must be evaluated before you run ert-test to test them, if you've updated the code."
186:   :properties '((file_path . ((type . "string")
187:                               (description . "Path to the file containing functions/defuns to evaluate")))
188:                 (function_names . ((type . "array")
189:                                    (items . ((type . "string")))
190:                                    (description . "List of function names to evaluate and run"))))
191:   :required '("file_path" "function_names")
192:   :function 'greger-tools--eval-elisp-defuns)
193:
194: (greger-register-tool "shell-command"
195:   :description "Execute an arbitrary shell command and return the output. Prompts for permission before running the command for security."
196:   :properties '((command . ((type . "string")
197:                             (description . "The shell command to execute")))
198:                 (working_directory . ((type . "string")
199:                                       (description . "Directory to run the command in")
200:                                       (default . "."))))
201:   :required '("command")
202:   :function 'greger-tools--shell-command)
203:
204: (greger-register-tool "read-webpage"
205:   :description "Read webpage content from a URL. Can return either extracted text or raw HTML."
206:   :properties '((url . ((type . "string")
207:                         (description . "The URL to read content from")))
208:                 (extract_text . ((type . "boolean")
209:                                  (description . "Whether to extract text content or return raw HTML")
210:                                  (default . t)))
211:                 (use_highest_readability . ((type . "boolean")
212:                                             (description . "Whether to use eww's aggressive highest readability setting for better text extraction")
213:                                             (default . nil))))
214:   :required '("url")
215:   :function 'greger-tools--read-webpage)
216:
217: ;; Helper functions
218:
219: (defun greger-tools--find-git-repo-root (start-dir)
220:   "Find the git repository root starting from START-DIR."
221:   (let ((dir (expand-file-name start-dir)))
222:     (while (and dir
223:                 (not (file-exists-p (expand-file-name ".git" dir)))
224:                 (not (string= dir (directory-file-name dir))))
225:       (setq dir (file-name-directory (directory-file-name dir))))
226:     (when (and dir (file-exists-p (expand-file-name ".git" dir)))
227:       dir)))
228:
229: ;; Tools below
230:
231: (defun greger-tools--git-stage-and-commit (files commit-message &optional chat-buffer)
232:   "Stage FILES and commit with COMMIT-MESSAGE using git command line.
233: If CHAT-BUFFER is provided, also stage and commit the chat buffer file."
234:   (condition-case err
235:       (let* ((first-file (car files))
236:              (file-dir (file-name-directory (expand-file-name first-file)))
237:              (repo-root (greger-tools--find-git-repo-root file-dir)))
238:         (unless repo-root
239:           (error "File %s is not in a git repository" first-file))
240:
241:         ;; Set default-directory to the repository root for git operations
242:         (let ((default-directory repo-root)
243:               (all-files files))
244:
245:           ;; Add chat buffer file if provided and it has a file
246:           (when (and chat-buffer (buffer-file-name chat-buffer))
247:             (let ((chat-file (buffer-file-name chat-buffer)))
248:               ;; Save the chat buffer first if it has unsaved changes
249:               (with-current-buffer chat-buffer
250:                 (when (buffer-modified-p)
251:                   (save-buffer)))
252:               ;; Add chat file to the list of files to stage
253:               (push chat-file all-files)))
254:
255:           ;; Stage the files
256:           (dolist (file all-files)
257:             (let ((relative-path (file-relative-name (expand-file-name file) repo-root)))
258:               (unless (= 0 (call-process "git" nil nil nil "add" relative-path))
259:                 (error "Failed to stage file: %s" file))))
260:
261:           ;; Create the commit
262:           (unless (= 0 (call-process "git" nil nil nil "commit" "-m" commit-message))
263:             (error "Failed to create commit"))
264:
265:           (format "Successfully staged %d file(s) and committed with message: %s"
266:                   (length all-files) commit-message)))
267:     (error
268:      (format "Git operation failed: %s" (error-message-string err)))))
269:
270: (defun greger-tools--read-file (path &optional include-line-numbers start-line end-line)
271:   "Read file at PATH. If INCLUDE-LINE-NUMBERS is non-nil, prepend line numbers.
272: If START-LINE is specified, start reading from that line (1-based).
273: If END-LINE is specified, stop reading at that line (inclusive, 1-based)."
274:   (unless (stringp path)
275:     (error "Path must be a string"))
276:
277:   (when (and start-line (not (integerp start-line)))
278:     (error "start-line must be an integer"))
279:
280:   (when (and end-line (not (integerp end-line)))
281:     (error "end-line must be an integer"))
282:
283:   (when (and start-line (< start-line 1))
284:     (error "start-line must be >= 1"))
285:
286:   (when (and end-line (< end-line 1))
287:     (error "end-line must be >= 1"))
288:
289:   (when (and start-line end-line (> start-line end-line))
290:     (error "start-line must be <= end-line"))
291:
292:   (let ((expanded-path (expand-file-name path)))
293:     (unless (file-exists-p expanded-path)
294:       (error "File does not exist: %s" expanded-path))
295:
296:     (unless (file-readable-p expanded-path)
297:       (error "File is not readable: %s" expanded-path))
298:
299:     (when (file-directory-p expanded-path)
300:       (error "Path is a directory, not a file: %s" expanded-path))
301:
302:     (condition-case err
303:         (with-temp-buffer
304:           (insert-file-contents expanded-path)
305:           (let* ((all-lines (split-string (buffer-string) "\n"))
306:                  (total-lines (length all-lines))
307:                  (actual-start (or start-line 1))
308:                  (actual-end (or end-line total-lines))
309:                  (selected-lines (greger-tools--extract-line-range all-lines actual-start actual-end))
310:                  (contents (mapconcat 'identity selected-lines "\n")))
311:             (if include-line-numbers
312:                 (greger-tools--add-line-numbers-with-offset contents actual-start)
313:               contents)))
314:       (error (format "Failed to read file: %s" (error-message-string err))))))
315:
316: (defun greger-tools--extract-line-range (lines start-line end-line)
317:   "Extract lines from LINES between START-LINE and END-LINE (1-based, inclusive)."
318:   (let ((start-index (1- start-line))  ; Convert to 0-based index
319:         (end-index (1- end-line)))     ; Convert to 0-based index
320:     ;; Ensure indices are within bounds
321:     (setq start-index (max 0 start-index))
322:     (setq end-index (min (1- (length lines)) end-index))
323:     ;; Extract the range
324:     (cl-subseq lines start-index (1+ end-index))))
325:
326: (defun greger-tools--add-line-numbers-with-offset (content start-line-num)
327:   "Add line numbers to CONTENT string starting from START-LINE-NUM."
328:   (let ((lines (split-string content "\n"))
329:         (line-num start-line-num)
330:         (max-width 0)
331:         result)
332:
333:     ;; Calculate the width needed for line numbers (based on the highest line number)
334:     (setq max-width (length (number-to-string (+ start-line-num (length lines) -1))))
335:
336:     ;; Add line numbers to each line
337:     (dolist (line lines)
338:       (push (format (concat "%" (number-to-string max-width) "d: %s") line-num line) result)
339:       (setq line-num (1+ line-num)))
340:
341:     ;; Join back with newlines
342:     (mapconcat 'identity (reverse result) "\n")))
343:
344: (defun greger-tools--list-directory (path &optional show-hidden recursive)
345:   "List directory contents at PATH."
346:   (unless (stringp path)
347:     (error "Path must be a string"))
348:
349:   (let ((expanded-path (expand-file-name path)))
350:     (unless (file-exists-p expanded-path)
351:       (error "Directory does not exist: %s" expanded-path))
352:
353:     (unless (file-directory-p expanded-path)
354:       (error "Path is not a directory: %s" expanded-path))
355:
356:     (unless (file-readable-p expanded-path)
357:       (error "Directory is not readable: %s" expanded-path))
358:
359:     (condition-case err
360:         (let ((files (if recursive
361:                          (greger-tools--list-directory-recursive expanded-path show-hidden)
362:                        (directory-files expanded-path nil
363:                                         (if show-hidden "^[^.]\\|^\\.[^.]" "^[^.]")))))
364:           (if files
365:               (mapconcat (lambda (file)
366:                            (let ((full-path (expand-file-name file expanded-path)))
367:                              (format "%s%s"
368:                                      file
369:                                      (if (file-directory-p full-path) "/" ""))))
370:                          files "\n")
371:             "Directory is empty"))
372:       (error (format "Failed to list directory: %s" (error-message-string err))))))
373:
374: (defun greger-tools--list-directory-recursive (path show-hidden &optional prefix)
375:   "Recursively list directory contents at PATH."
376:   (let ((files '())
377:         (prefix (or prefix "")))
378:
379:     (dolist (file (directory-files path nil
380:                                    (if show-hidden "^[^.]\\|^\\.[^.]" "^[^.]")))
381:       (let ((full-path (expand-file-name file path))
382:             (display-name (concat prefix file)))
383:
384:         (if (file-directory-p full-path)
385:             (progn
386:               (push (concat display-name "/") files)
387:               (setq files (append files
388:                                   (greger-tools--list-directory-recursive
389:                                    full-path show-hidden (concat prefix file "/")))))
390:           (push display-name files))))
391:
392:     (reverse files)))
393:
394: (defun greger-tools--ripgrep (pattern path &optional case-sensitive file-type context-lines max-results)
395:   "Search for PATTERN in PATH using the rg command line tool directly."
396:   (unless (stringp pattern)
397:     (error "Pattern must be a string"))
398:
399:   (unless (stringp path)
400:     (error "Path must be a string"))
401:
402:   ;; Check if rg executable is available
403:   (unless (executable-find "rg")
404:     (error "ripgrep (rg) command not found. Please install ripgrep"))
405:
406:   (let ((expanded-path (expand-file-name path)))
407:     (unless (file-exists-p expanded-path)
408:       (error "Path does not exist: %s" expanded-path))
409:
410:     ;; Build the rg command arguments
411:     (let ((args '("rg")))
412:
413:       ;; Add case sensitivity flag
414:       (if case-sensitive
415:           (setq args (append args '("--case-sensitive")))
416:         (setq args (append args '("--smart-case"))))
417:
418:       ;; Add context lines if specified
419:       (when (and context-lines (> context-lines 0))
420:         (setq args (append args (list "--context" (number-to-string context-lines)))))
421:
422:       ;; Add max results limit if specified (using --max-count)
423:       (when (and max-results (> max-results 0))
424:         (setq args (append args (list "--max-count" (number-to-string max-results)))))
425:
426:       ;; Add file type if specified
427:       (when (and file-type (not (string-empty-p file-type)))
428:         (setq args (append args (list "--type" file-type))))
429:
430:       ;; Add line numbers and no heading for better output format
431:       (setq args (append args '("--line-number" "--no-heading")))
432:
433:       ;; Add the pattern and path
434:       (setq args (append args (list pattern expanded-path)))
435:
436:       (condition-case err
437:           (let ((command (mapconcat 'shell-quote-argument args " ")))
438:             ;; Execute the command and capture output
439:             (let ((output (shell-command-to-string command)))
440:               ;; Return results or indicate no matches
441:               (if (string-empty-p (string-trim output))
442:                   "No matches found"
443:                 output)))
444:         (error (format "Failed to execute ripgrep search: %s" (error-message-string err)))))))
445:
446: (defun greger-tools--write-new-file (file-path contents git-commit-message &optional buffer)
447:   "Write CONTENTS to a new file at FILE-PATH. Fails if file already exists.
448: If BUFFER is provided, it will be staged and committed along with the new file."
449:   (unless (stringp file-path)
450:     (error "file_path must be a string"))
451:
452:   (unless (stringp contents)
453:     (error "contents must be a string"))
454:
455:   (let ((expanded-path (expand-file-name file-path)))
456:
457:     ;; Check if file already exists
458:     (when (file-exists-p expanded-path)
459:       (error "File already exists: %s" expanded-path))
460:
461:     ;; Check if parent directory exists, if not create it
462:     (let ((parent-dir (file-name-directory expanded-path)))
463:       (unless (file-exists-p parent-dir)
464:         (make-directory parent-dir t)))
465:
466:     ;; Write the file
467:     (condition-case err
468:         (with-temp-buffer
469:           (insert contents)
470:           (write-file expanded-path))
471:       (error (format "Failed to write file: %s" (error-message-string err))))
472:
473:     ;; Stage and commit changes - infer the file to stage
474:     (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) git-commit-message buffer)))
475:       (format "Successfully wrote new file %s with %d characters. %s"
476:               expanded-path (length contents) git-result))))
477:
478: (defun greger-tools--make-directory (path git-commit-message &optional buffer)
479:   "Recursively create directory at PATH.
480: If BUFFER is provided, it will be staged and committed along with the directory."
481:   (unless (stringp path)
482:     (error "path must be a string"))
483:
484:   (let ((expanded-path (expand-file-name path)))
485:
486:     ;; Check if path already exists
487:     (if (file-exists-p expanded-path)
488:         (if (file-directory-p expanded-path)
489:             (format "Directory already exists: %s" expanded-path)
490:           (error "Path exists but is not a directory: %s" expanded-path))
491:
492:       ;; Create directory recursively
493:       (condition-case err
494:           (progn
495:             (make-directory expanded-path t)
496:             ;; For directory creation, we might want to stage a .gitkeep file or similar
497:             ;; For now, we'll stage the directory path itself (though git doesn't track empty dirs)
498:             (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) git-commit-message buffer)))
499:               (format "Successfully created directory: %s. %s" expanded-path git-result)))
500:         (error (format "Failed to create directory: %s" (error-message-string err)))))))
501:
502: (defun greger-tools--rename-file (old-path new-path git-commit-message &optional buffer)
503:   "Rename file from OLD-PATH to NEW-PATH.
504: If BUFFER is provided, it will be staged and committed along with the renamed file."
505:   (unless (stringp old-path)
506:     (error "old_path must be a string"))
507:
508:   (unless (stringp new-path)
509:     (error "new_path must be a string"))
510:
511:   (let ((expanded-old-path (expand-file-name old-path))
512:         (expanded-new-path (expand-file-name new-path)))
513:
514:     ;; Check if old file exists
515:     (unless (file-exists-p expanded-old-path)
516:       (error "Source file does not exist: %s" expanded-old-path))
517:
518:     ;; Check if new file already exists
519:     (when (file-exists-p expanded-new-path)
520:       (error "Destination file already exists: %s" expanded-new-path))
521:
522:     ;; Ensure destination directory exists
523:     (let ((parent-dir (file-name-directory expanded-new-path)))
524:       (unless (file-exists-p parent-dir)
525:         (make-directory parent-dir t)))
526:
527:     ;; Rename the file
528:     (condition-case err
529:         (progn
530:           (rename-file expanded-old-path expanded-new-path)
531:           ;; Stage both old and new paths (git mv operation)
532:           (let ((git-result (greger-tools--git-stage-and-commit
533:                              (list expanded-old-path expanded-new-path)
534:                              git-commit-message buffer)))
535:             (format "Successfully renamed %s to %s. %s" expanded-old-path expanded-new-path git-result)))
536:       (error (format "Failed to rename file: %s" (error-message-string err))))))
537:
538: (defun greger-tools--replace-function (file-path function-name contents line-number commit-message &optional buffer)
539:   "Replace FUNCTION-NAME in FILE-PATH with new CONTENTS at LINE-NUMBER.
540: If BUFFER is provided, it will be staged and committed along with the modified file."
541:   (unless (stringp file-path)
542:     (error "file_path must be a string"))
543:
544:   (unless (stringp function-name)
545:     (error "function_name must be a string"))
546:
547:   (unless (stringp contents)
548:     (error "contents must be a string"))
549:
550:   (unless (integerp line-number)
551:     (error "line_number must be an integer"))
552:
553:   (unless (stringp commit-message)
554:     (error "commit_message must be a string"))
555:
556:   (let ((expanded-path (expand-file-name file-path)))
557:
558:     ;; Check if file exists
559:     (unless (file-exists-p expanded-path)
560:       (error "File does not exist: %s" expanded-path))
561:
562:     ;; Check file extension for supported languages
563:     (unless (or (string-suffix-p ".py" expanded-path)
564:                 (string-suffix-p ".el" expanded-path))
565:       (error "Only Python (.py) and Elisp (.el) files are supported"))
566:
567:     (with-current-buffer (find-file-noselect expanded-path)
568:      ;; Go to the specified line number
569:      (goto-line line-number)
570:
571:      ;; Verify function name is at this line
572:      (beginning-of-line)
573:      (let ((line-content (buffer-substring-no-properties
574:                           (line-beginning-position)
575:                           (line-end-position))))
576:
577:        ;; Check if function is defined on this line based on file type
578:        (let ((function-pattern
579:               (cond
580:                ((string-suffix-p ".py" expanded-path)
581:                 (format "^\\s-*def\\s-+%s\\s-*(" (regexp-quote function-name)))
582:                ((string-suffix-p ".el" expanded-path)
583:                 (format "^\\s-*(defun\\s-+%s\\s-*(" (regexp-quote function-name)))
584:                (t (error "Unsupported file type")))))
585:
586:          (unless (string-match-p function-pattern line-content)
587:            (error "Function '%s' not found at line %d in %s. Line content: %s"
588:                   function-name line-number expanded-path line-content))))
589:
590:      ;; Delete the existing function using end-of-defun then beginning-of-defun
591:      (let (start-pos end-pos)
592:        ;; First go to end of defun to get the end position
593:        (end-of-defun)
594:        (setq end-pos (point))
595:
596:        ;; Then go to beginning of defun to get start position
597:        (beginning-of-defun)
598:        (setq start-pos (point))
599:
600:        ;; Delete the function
601:        (delete-region start-pos end-pos)
602:
603:        ;; Insert new contents
604:        (insert contents)
605:
606:        ;; Ensure there's a newline at the end if not present
607:        (unless (string-suffix-p "\n" contents)
608:          (insert "\n")))
609:
610:      ;; Save the file
611:      (save-buffer))
612:
613:     ;; Stage and commit the file
614:     (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) commit-message buffer)))
615:       (format "Successfully replaced function '%s' in %s. %s"
616:               function-name expanded-path git-result))))
617:
618: (defun greger-tools--replace-file (file-path contents git-commit-message &optional buffer)
619:   "Replace the entire contents of FILE-PATH with CONTENTS.
620: If BUFFER is provided, it will be staged and committed along with the modified file."
621:   (unless (stringp file-path)
622:     (error "file_path must be a string"))
623:
624:   (unless (stringp contents)
625:     (error "contents must be a string"))
626:
627:   (unless (stringp git-commit-message)
628:     (error "git_commit_message must be a string"))
629:
630:   (let ((expanded-path (expand-file-name file-path)))
631:
632:     ;; Check if file exists
633:     (unless (file-exists-p expanded-path)
634:       (error "File does not exist: %s" expanded-path))
635:
636:     ;; Check if it's actually a file and not a directory
637:     (when (file-directory-p expanded-path)
638:       (error "Path is a directory, not a file: %s" expanded-path))
639:
640:     (with-current-buffer (find-file-noselect expanded-path)
641:      ;; Select all content and replace it
642:      (erase-buffer)
643:      (insert contents)
644:
645:      ;; Save the file
646:      (save-buffer))
647:
648:     ;; Stage and commit the file
649:     (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) git-commit-message buffer)))
650:       (format "Successfully replaced contents of %s with %d characters. %s"
651:               expanded-path (length contents) git-result))))
652:
653: (defun greger-tools--str-replace (file-path original-content new-content git-commit-message &optional buffer)
654:   "Replace ORIGINAL-CONTENT with NEW-CONTENT in FILE-PATH.
655: If BUFFER is provided, it will be staged and committed along with the modified file."
656:   (unless (stringp file-path)
657:     (error "file_path must be a string"))
658:
659:   (unless (stringp original-content)
660:     (error "original_content must be a string"))
661:
662:   (unless (stringp new-content)
663:     (error "new_content must be a string"))
664:
665:   (unless (stringp git-commit-message)
666:     (error "git_commit_message must be a string"))
667:
668:   (let ((expanded-path (expand-file-name file-path)))
669:
670:     ;; Check if file exists
671:     (unless (file-exists-p expanded-path)
672:       (error "File does not exist: %s" expanded-path))
673:
674:     ;; Check if it's actually a file and not a directory
675:     (when (file-directory-p expanded-path)
676:       (error "Path is a directory, not a file: %s" expanded-path))
677:
678:     (with-current-buffer (find-file-noselect expanded-path)
679:      ;; Use isearch to find the original content
680:      (goto-char (point-min))
681:      (let ((case-fold-search nil)) ; Make search case-sensitive
682:        (if (search-forward original-content nil t)
683:            (progn
684:              ;; Replace the found content
685:              (replace-match new-content nil t)
686:              ;; Save the file
687:              (save-buffer))
688:          (error "Original content not found in file: %s -- Try again!" expanded-path))))
689:
690:     ;; Stage and commit the file
691:     (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) git-commit-message buffer)))
692:       (format "Successfully replaced content in %s. %s" expanded-path git-result))))
693:
694: (defun greger-tools--insert (file-path line-number content git-commit-message &optional buffer)
695:   "Insert CONTENT at LINE-NUMBER in FILE-PATH.
696: If BUFFER is provided, it will be staged and committed along with the modified file."
697:   (unless (stringp file-path)
698:     (error "file_path must be a string"))
699:
700:   (unless (integerp line-number)
701:     (error "line_number must be an integer"))
702:
703:   (unless (>= line-number 0)
704:     (error "line_number must be >= 0"))
705:
706:   (unless (stringp content)
707:     (error "content must be a string"))
708:
709:   (unless (stringp git-commit-message)
710:     (error "git_commit_message must be a string"))
711:
712:   (let ((expanded-path (expand-file-name file-path)))
713:
714:     ;; Check if file exists
715:     (unless (file-exists-p expanded-path)
716:       (error "File does not exist: %s" expanded-path))
717:
718:     ;; Check if it's actually a file and not a directory
719:     (when (file-directory-p expanded-path)
720:       (error "Path is a directory, not a file: %s" expanded-path))
721:
722:     (with-current-buffer (find-file-noselect expanded-path)
723:      ;; Navigate to the insertion point
724:      (goto-char (point-min))
725:      (if (= line-number 0)
726:          ;; Insert at beginning of file
727:          (goto-char (point-min))
728:        ;; Go to the specified line - this is where the fix is needed
729:        (goto-line line-number)
730:        ;; Move to beginning of line to insert before it, not after it
731:        (beginning-of-line))
732:
733:      ;; Insert the content
734:      (if (= line-number 0)
735:          ;; At beginning of file, insert content and newline
736:          (progn
737:            (insert content)
738:            (unless (string-suffix-p "\n" content)
739:              (insert "\n")))
740:        ;; Before a line, insert content then newline
741:        (progn
742:          (insert content)
743:          (unless (string-suffix-p "\n" content)
744:            (insert "\n"))))
745:
746:      ;; Save the file
747:      (save-buffer))
748:
749:     ;; Stage and commit the file
750:     (let ((git-result (greger-tools--git-stage-and-commit (list expanded-path) git-commit-message buffer)))
751:       (format "Successfully inserted %d characters at line %d in %s. %s"
752:               (length content) line-number expanded-path git-result))))
753:
754: (defun greger-tools--git-log (path &optional max-rows)
755:   "View git commit logs using git command line for PATH."
756:   (unless (stringp path)
757:     (error "path must be a string"))
758:
759:   (let ((expanded-path (expand-file-name path))
760:         (max-count (or max-rows 100)))
761:
762:     (unless (file-exists-p expanded-path)
763:       (error "Path does not exist: %s" expanded-path))
764:
765:     ;; Get the directory to search for git repo (if path is a file, use its directory)
766:     (let* ((search-dir (if (file-directory-p expanded-path)
767:                           expanded-path
768:                         (file-name-directory expanded-path)))
769:            (repo-root (greger-tools--find-git-repo-root search-dir)))
770:       (unless repo-root
771:         (error "Path %s is not in a git repository" expanded-path))
772:
773:       (condition-case err
774:           (let ((default-directory repo-root))
775:             (with-temp-buffer
776:               (let ((exit-code (call-process "git" nil t nil "log"
777:                                            "--oneline" "--decorate" "--graph"
778:                                            (format "--max-count=%d" max-count))))
779:                 (if (= exit-code 0)
780:                     (let ((results (buffer-string)))
781:                       (if (string-empty-p (string-trim results))
782:                           "No git log available"
783:                         results))
784:                   (error "Git log command failed with exit code %d" exit-code)))))
785:         (error (format "Failed to retrieve git log: %s" (error-message-string err)))))))
786:
787: (defun greger-tools--git-show-commit (commit-hash path)
788:   "View git commit using git command line for PATH."
789:   (unless (stringp commit-hash)
790:     (error "commit_hash must be a string"))
791:
792:   (unless (stringp path)
793:     (error "path must be a string"))
794:
795:   (let ((expanded-path (expand-file-name path)))
796:
797:     (unless (file-exists-p expanded-path)
798:       (error "Path does not exist: %s" expanded-path))
799:
800:     ;; Get the directory to search for git repo (if path is a file, use its directory)
801:     (let* ((search-dir (if (file-directory-p expanded-path)
802:                           expanded-path
803:                         (file-name-directory expanded-path)))
804:            (repo-root (greger-tools--find-git-repo-root search-dir)))
805:       (unless repo-root
806:         (error "Path %s is not in a git repository" expanded-path))
807:
808:       (condition-case err
809:           (let ((default-directory repo-root))
810:             (with-temp-buffer
811:               (let ((exit-code (call-process "git" nil t nil "show" commit-hash)))
812:                 (if (= exit-code 0)
813:                     (let ((results (buffer-string)))
814:                       (if (string-empty-p (string-trim results))
815:                           "No git commit available"
816:                         results))
817:                   (error "Git show command failed with exit code %d" exit-code)))))
818:         (error (format "Failed to show git commit: %s" (error-message-string err)))))))
819:
820: (defun greger-tools--eval-elisp-defuns (file-path function-names)
821:   (unless (stringp file-path)
822:     (error "File path must be a string"))
823:
824:   (unless (vectorp function-names)
825:     (error "Function names must be a vector"))
826:
827:   (let ((expanded-path (expand-file-name file-path)))
828:     ;; Check if file exists
829:     (unless (file-exists-p expanded-path)
830:       (error "File does not exist: %s" expanded-path))
831:
832:     ;; Check if it's actually a file
833:     (when (file-directory-p expanded-path)
834:       (error "Path is a directory, not a file: %s" expanded-path))
835:
836:     (with-current-buffer (find-file-noselect expanded-path)
837:      ;; Navigate to and evaluate each function
838:      (dotimes (i (length function-names))
839:        (let ((function-name (aref function-names i)))
840:          (goto-char (point-min))
841:
842:          ;; Search for the function definition
843:          (let ((function-pattern (format "^\\s-*(\\(ert-deftest\\|defun\\)\\s-+%s\\s-*("
844:                                          (regexp-quote function-name))))
845:            (unless (re-search-forward function-pattern nil t)
846:              (error "Function '%s' not found in %s" function-name expanded-path))
847:
848:            ;; Move to beginning of defun and evaluate it
849:            (beginning-of-defun)
850:            (eval-defun nil)))))
851:     "Eval successful"))
852:
853: (defun greger-tools--ert-test (test-file-path function-names)
854:   "Execute ERT tests by evaluating test functions and running them with ert.
855: TEST-FILE-PATH is the path to the test file.
856: FUNCTION-NAMES is a vector of test function names to evaluate and run."
857:
858:   ;; First eval the test function names
859:   (greger-tools--eval-elisp-defuns test-file-path function-names)
860:
861:   (condition-case err
862:       (progn
863:         ;; Now run the tests using ert-run-tests with a custom listener
864:         (let* ((function-names-list (append function-names nil)) ; Convert vector to list for processing
865:                (test-selector `(member ,@(mapcar #'intern function-names-list)))
866:                (output-lines '())
867:                (stats nil))
868:
869:           ;; Define a custom listener to capture test output
870:           (let ((listener
871:                  (lambda (event-type &rest event-args)
872:                    (cl-case event-type
873:                      (run-started
874:                       (cl-destructuring-bind (stats-obj) event-args
875:                         (setq stats stats-obj)
876:                         (push (format "Running %d tests (%s)"
877:                                       (length (ert--stats-tests stats-obj))
878:                                       (current-time-string))
879:                               output-lines)))
880:                      (test-started
881:                       (cl-destructuring-bind (stats-obj test) event-args
882:                         (push (format "Test %S started" (ert-test-name test))
883:                               output-lines)))
884:                      (test-ended
885:                       (cl-destructuring-bind (stats-obj test result) event-args
886:                         (let ((test-name (ert-test-name test))
887:                               (expected-p (ert-test-result-expected-p test result)))
888:                           (push (format "Test %S: %s%s%s"
889:                                         test-name
890:                                         (ert-string-for-test-result result expected-p)
891:                                         (if (ert-test-result-duration result)
892:                                             (format " (%.3fs)" (ert-test-result-duration result))
893:                                           "")
894:                                         (let ((reason (ert-reason-for-test-result result)))
895:                                           (if (string-empty-p reason) "" reason)))
896:                                 output-lines)
897:                           ;; Add condition details for failures
898:                           (when (and (ert-test-result-with-condition-p result)
899:                                      (not expected-p))
900:                             (let ((condition (ert-test-result-with-condition-condition result)))
901:                               (push (format "  Condition: %S" condition) output-lines))))))
902:                      (run-ended
903:                       (cl-destructuring-bind (stats-obj aborted-p) event-args
904:                         (let ((completed (ert-stats-completed stats-obj))
905:                               (expected (ert-stats-completed-expected stats-obj))
906:                               (unexpected (ert-stats-completed-unexpected stats-obj))
907:                               (skipped (ert-stats-skipped stats-obj)))
908:                           (push (format "\n%sRan %d tests, %d results as expected, %d unexpected%s"
909:                                         (if aborted-p "Aborted: " "")
910:                                         completed
911:                                         expected
912:                                         unexpected
913:                                         (if (zerop skipped) "" (format ", %d skipped" skipped)))
914:                                 output-lines))))))))
915:
916:             ;; Run the tests
917:             (setq stats (ert-run-tests test-selector listener))
918:
919:             ;; Format the results
920:             (let ((result-text (string-join (nreverse output-lines) "\n")))
921:               (format "Successfully evaluated %d test function(s) from %s and executed them with ert.\n\nTest Results:\n%s"
922:                       (length function-names) test-file-path result-text)))))
923:
924:     (error (format "Failed to execute ERT tests: %s" (error-message-string err)))))
925:
926: (defun greger-tools--shell-command (command &optional working-directory)
927:   "Execute COMMAND in WORKING-DIRECTORY and return the output.
928: Prompts for permission before running the command for security."
929:   (unless (stringp command)
930:     (error "Command must be a string"))
931:
932:   (when (string-empty-p (string-trim command))
933:     (error "Command cannot be empty"))
934:
935:   (let ((work-dir (or working-directory ".")))
936:     (unless (stringp work-dir)
937:       (error "Working directory must be a string"))
938:
939:     (let ((expanded-work-dir (expand-file-name work-dir)))
940:       (unless (file-exists-p expanded-work-dir)
941:         (error "Working directory does not exist: %s" expanded-work-dir))
942:
943:       (unless (file-directory-p expanded-work-dir)
944:         (error "Working directory path is not a directory: %s" expanded-work-dir))
945:
946:       ;; Prompt for permission to run the command
947:       (unless (y-or-n-p (format "Execute shell command: '%s' in directory '%s'? "
948:                                 command expanded-work-dir))
949:         (error "Shell command execution cancelled by user"))
950:
951:       (condition-case err
952:           (let ((default-directory expanded-work-dir)
953:                 (output "")
954:                 (exit-code 0))
955:             ;; Execute the command and capture both output and exit code
956:             (with-temp-buffer
957:               (setq exit-code (call-process-shell-command command nil t nil))
958:               (setq output (buffer-string)))
959:
960:             ;; Format the result with exit code information
961:             (if (= exit-code 0)
962:                 (format "Command executed successfully (exit code 0):\n%s"
963:                         (if (string-empty-p (string-trim output))
964:                             "(no output)"
965:                           output))
966:               (format "Command failed with exit code %d:\n%s"
967:                       exit-code
968:                       (if (string-empty-p (string-trim output))
969:                           "(no output)"
970:                         output))))
971:         (error (format "Failed to execute shell command: %s" (error-message-string err)))))))
972:
973: (defun greger-tools--read-webpage (url &optional extract-text use-highest-readability)
974:   "Read webpage content from URL.
975: If EXTRACT-TEXT is non-nil (default t), extract and return text content.
976: If EXTRACT-TEXT is nil, return raw HTML.
977: If USE-HIGHEST-READABILITY is non-nil, use eww's aggressive readability setting."
978:   (unless (stringp url)
979:     (error "URL must be a string"))
980:
981:   (when (string-empty-p (string-trim url))
982:     (error "URL cannot be empty"))
983:
984:   (unless (greger-web-is-web-url-p url)
985:     (error "Invalid URL format: %s (must start with http:// or https://)" url))
986:
987:   (condition-case err
988:       (greger-web-download-page url extract-text use-highest-readability)
989:     (error (format "Failed to read webpage: %s" (error-message-string err)))))
990:
991: (provide 'greger-stdlib)
992:
993: ;;; greger-stdlib.el ends here
994:
</tool.toolu_013ayqdde6MgzHqjGcpThfss>

## ASSISTANT:

Now I need to find the `greger-tools--git-stage-and-commit` function and modify it to check if the chat file is already tracked in version control before staging it. Let me look at the function starting at line 231:

## TOOL USE:

Name: read-file
ID: toolu_012Mae2myEr61N9T5u1bDemw

### path

<tool.toolu_012Mae2myEr61N9T5u1bDemw>
greger-stdlib.el
</tool.toolu_012Mae2myEr61N9T5u1bDemw>

### start_line

<tool.toolu_012Mae2myEr61N9T5u1bDemw>
231
</tool.toolu_012Mae2myEr61N9T5u1bDemw>

### end_line

<tool.toolu_012Mae2myEr61N9T5u1bDemw>
268
</tool.toolu_012Mae2myEr61N9T5u1bDemw>

### include_line_numbers

<tool.toolu_012Mae2myEr61N9T5u1bDemw>
true
</tool.toolu_012Mae2myEr61N9T5u1bDemw>

## TOOL RESULT:

ID: toolu_012Mae2myEr61N9T5u1bDemw

<tool.toolu_012Mae2myEr61N9T5u1bDemw>
231: (defun greger-tools--git-stage-and-commit (files commit-message &optional chat-buffer)
232:   "Stage FILES and commit with COMMIT-MESSAGE using git command line.
233: If CHAT-BUFFER is provided, also stage and commit the chat buffer file."
234:   (condition-case err
235:       (let* ((first-file (car files))
236:              (file-dir (file-name-directory (expand-file-name first-file)))
237:              (repo-root (greger-tools--find-git-repo-root file-dir)))
238:         (unless repo-root
239:           (error "File %s is not in a git repository" first-file))
240:
241:         ;; Set default-directory to the repository root for git operations
242:         (let ((default-directory repo-root)
243:               (all-files files))
244:
245:           ;; Add chat buffer file if provided and it has a file
246:           (when (and chat-buffer (buffer-file-name chat-buffer))
247:             (let ((chat-file (buffer-file-name chat-buffer)))
248:               ;; Save the chat buffer first if it has unsaved changes
249:               (with-current-buffer chat-buffer
250:                 (when (buffer-modified-p)
251:                   (save-buffer)))
252:               ;; Add chat file to the list of files to stage
253:               (push chat-file all-files)))
254:
255:           ;; Stage the files
256:           (dolist (file all-files)
257:             (let ((relative-path (file-relative-name (expand-file-name file) repo-root)))
258:               (unless (= 0 (call-process "git" nil nil nil "add" relative-path))
259:                 (error "Failed to stage file: %s" file))))
260:
261:           ;; Create the commit
262:           (unless (= 0 (call-process "git" nil nil nil "commit" "-m" commit-message))
263:             (error "Failed to create commit"))
264:
265:           (format "Successfully staged %d file(s) and committed with message: %s"
266:                   (length all-files) commit-message)))
267:     (error
268:      (format "Git operation failed: %s" (error-message-string err)))))
</tool.toolu_012Mae2myEr61N9T5u1bDemw>

## ASSISTANT:

Now I need to modify the function to check if the chat file is already tracked in version control before adding it to the list of files to stage. I'll add a helper function to check if a file is tracked by git, and then modify the existing function:
