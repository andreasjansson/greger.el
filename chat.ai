## SYSTEM:


<safe-shell-commands>
bash script/lint
bash script/test
bash script/test --verbose --file test/test-end-to-end.el
bash script/test --verbose --file test/test-greger-client.el
bash script/test --verbose --file test/test-greger-parser.el
bash script/test --verbose --file test/test-greger-stdlib.el
bash script/test --verbose --file test/test-greger-tools.el
bash script/test --verbose --file test/test-greger.el
</safe-shell-commands>

## USER:

I've made a small start at adding support for citations in greger-parser.el. Finish the implementation.

Citations are used in web search tool results, documented here: https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool.md

Note that the citations are folded up with the assistant message.

I want the following formatting:

``` markdown
## USER:

When was Claude Shannon born?

## SERVER TOOL USE:

Name: web_search
ID: srvtoolu_01WYG3ziw53XMcoyKL4XcZmE

### query

<tool.srvtoolu_01PTAPErPmrfeuS9wPASo4dL>
claude shannon birth date
</tool.srvtoolu_01PTAPErPmrfeuS9wPASo4dL>

## SERVER TOOL RESULT:

ID: srvtoolu_01PTAPErPmrfeuS9wPASo4dL

<tool.srvtoolu_01PTAPErPmrfeuS9wPASo4dL>
[
  {
    "type": "web_search_result",
    "url": "https://en.wikipedia.org/wiki/Claude_Shannon",
    "title": "Claude Shannon - Wikipedia",
    "encrypted_content": "EqgfCioIARgBIiQ3YTAwMjY1Mi1mZjM5LTQ1NGUtODgxNC1kNjNjNTk1ZWI3Y...",
    "page_age": "April 30, 2025"
  }
]
</tool.srvtoolu_01PTAPErPmrfeuS9wPASo4dL>

## ASSISTANT:

Based on the search results, <cite>Claude Shannon was born on April 30, 1916, in Petoskey, Michigan</cite>

## CITATIONS:

### https://en.wikipedia.org/wiki/Claude_Shannon

Title: Claude Shannon - Wikipedia
Cited text: Claude Elwood Shannon (April 30, 1916 â€“ February 24, 2001) was an American mathematician, electrical engineer, computer scientist, cryptographer and i...
Encrypted index: Eo8BCioIAhgBIiQyYjQ0OWJmZi1lNm..
```

followed by potentially other citations in the form

```
### URL

Title: title
Encrypted index: encrypted_index
Cited text: cited_text
```

Note that:
* `type` is always `web_search_result_location`
* The URL is in the heading
* I want it ordered like it is in my example, with title first and encrypted index last
* The text in the list item with the citations object is wrapped in `<cite>`, but otherwise folded into the previous ASSISTANT: section.

The implementation of the above works in the parser, but citation messages are not handled in greger-client.el or greger.el. 

Here's an example of `output` chunks being passed to greger-client--process-output-chunk:

```
event: content_block_start
data: {"type":"content_block_start","index":2,"content_block":{"type":"text","text":""}      }

event: content_block_delta
data: {"type":"content_block_delta","index":2,"delta":{"type":"text_delta","text":"The"}    }
 [2 times]
output: event: content_block_delta
data: {"type":"content_block_delta","index":2,"delta":{"type":"text_delta","text":" current king of Sweden is "}   }
 [2 times]
output: event: content_block_stop
data: {"type":"content_block_stop","index":2        }

event: content_block_start
data: {"type":"content_block_start","index":3,"content_block":{"citations":[],"type":"text","text":""}              }
 [2 times]
output: event: content_block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"Carl XVI Gustaf (Carl Gustaf Folke Hubertus; born 30 April 1946) is King of Sweden. ","url":"https://en.wikipedia.org/wiki/Carl_XVI_Gustaf","title":"Carl XVI Gustaf - Wikipedia","encrypted_index":"EpABCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDM6TZF7d38lQ9CvfRxoM70njkWWeMoYCNgepIjASsG+1BpXEH7X3Csi9maAj0FG85GhN1PcxqwT9aDUlMZjE2vishIouK3DF6xz7/n4qFJ9pxzVP8/BHgz5XBzYFqWX+hgqtGAQ="}}     }

event: content_block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"The current king of Sweden is Carl XVI Gustaf, while his heir is Crown Princess Victoria. ","url":"https://en.wikipedia.org/wiki/Monarchy_of_Sweden","title":"Monarchy of Sweden - Wikipedia","encrypted_index":"Eo8BCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDAl+q
output: ZGj/EpDhQ0qMxoMm/ESyU7rOGybCvcPIjBnHX/EZ5v283Ic7Bprg5Su8lg/IbOBiLw4+IwxYLcdGaP0sc3Kk7zhL3W7IlTDmpMqEw7sZhecEb8Oj8J246xSJob2uIwYBA=="}}   }

event: content_block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"This is the motto of King Carl XVI Gustaf, Sweden's Head of State and foremost representative of the Swedish royal family. ","url":"https://sweden.se/life/people/the-swedish-royal-family","title":"The Swedish royal family | sweden.se","encrypted_index":"EpABCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDNpnXG14vU9Mm8tW4xoMGpL78Pg78aoR5gr5IjA8qDz3N6NrXUy/Wbe+ERcGui8E8iwyWFb8W3tolDpFOuK+KZgSle1V+oD2s1enS+0qFD8JpT9ow5M8zrh4x9X7wJmFVa35GAQ="}}             }

event: content_block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"Sweden's current king, Carl XVI Gustaf, ascended to the throne on 15 Sept
output: ember 1973 and is the country's 74th monarch. ","url":"https://www.kungahuset.se/english/the-monarchy-of-sweden","title":"The monarchy of Sweden | Kungahuset","encrypted_index":"EpABCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDLD+NtB7NyctsPryDBoMxFnm73GwWyxsUe2lIjCKtNBfm4ltn8uYashVQDC+J4xAbjRCp5U0cojuCLIW7bX+ag8WcnotOl+5IZrXEv4qFAtDyFR4pGP0tl2TO7aJiYjWWECVGAQ="}}       }

event: content_block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"CARL GUSTAF Folke Hubertus, King of Sweden, born on 30 April, 1946, ascended the throne on 15 September 1973. ","url":"https://www.kungahuset.se/english/royal-house/hm-the-king","title":"HM The King | Kungahuset","encrypted_index":"Eo8BCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDEhEkXqsSPNZQ61GqBoM67xzLLIGFKpnVjQlIjC8BGEbjfurLKUNqrD5CdQvKfo0uJg6CVQSHf/BxJXwMGrkVWbRd0cDd2G5NgdRIdMqE9Xy4O4rWLdS789MHlsTrYPUrT0YBA=="}}           }

event: content_
output: block_delta
data: {"type":"content_block_delta","index":3,"delta":{"type":"text_delta","text":"Carl XVI Gustaf"} }

event: content_block_stop
data: {"type":"content_block_stop","index":3 }

event: content_block_start
data: {"type":"content_block_start","index":4,"content_block":{"type":"text","text":""}            }

event: content_block_delta
data: {"type":"content_block_delta","index":4,"delta":{"type":"text_delta","text":". "}               }

event: content_block_stop
data: {"type":"content_block_stop","index":4 }
 [2 times]
output: event: content_block_start
data: {"type":"content_block_start","index":5,"content_block":{"citations":[],"type":"text","text":""}     }

event: content_block_delta
data: {"type":"content_block_delta","index":5,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"Carl XVI Gustaf (Carl Gustaf Folke Hubertus; born 30 April 1946) is King of Sweden. ","url":"https://en.wikipedia.org/wiki/Carl_XVI_Gustaf","title":"Carl XVI Gustaf - Wikipedia","encrypted_index":"EpABCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDJEO38udBl+OBMQAgxoMbf6XGVoq1PK9do/RIjDrAEDWScpCI4vM7NY/+szi2TolJy0YCecJpx3qXpZd2WHzpQwcz38ORxHUKimDd0kqFKVfkrE8MQBLBqgMB+cSn9ZvDA6yGAQ="}}              }

event: content_block_delta
data: {"type":"content_block_delta","index":5,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location","cited_text":"CARL GUSTAF Folke Hubertus, King of Sweden, born on 30 April, 1946, ascended the throne on 15 September 1973. ","url":"https://www.k
output: ungahuset.se/english/royal-house/hm-the-king","title":"HM The King | Kungahuset","encrypted_index":"Eo8BCioIBBgCIiQ1OTMxOGJiOC0zZjNhLTQ0Y2UtOWFkNS0wYzYxNWE4MGI0YWISDAvzaaSO5zqYn2o/UxoM63SqhOe4srrGROlGIjA/jUAzywRSqzeDLikY5Svr5OttIn+SeXnzXEtONMtJ+P2j95DLhqCoydpZpBFpmMEqEx0wIoXZH4LcYRFQmYXltSS1W+YYBA=="}}           }

event: content_block_delta
data: {"type":"content_block_delta","index":5,"delta":{"type":"text_delta","text":"Born on April 30, 1946"}      }
 [2 times]
output: event: content_block_stop
data: {"type":"content_block_stop","index":5     }
 [2 times]
Interrupting generation
output: event: content_block_start
data: {"type":"content_block_start","index":6,"content_block":{"type":"text","text":""} }

event: content_block_delta
data: {"type":"content_block_delta","index":6,"delta":{"type":"text_delta","text":", he "}       }
```

You'll need to handle the citation_delta (which appens an item to the citation object) as well as text_delta when the object is a citation. When the object is a citation, we shouldn't stream the text output, but handle in the block stop callback.

## ASSISTANT:

I'll examine the current implementation and then finish the citation support. Let me start by looking at the existing code structure.

## TOOL USE:

Name: list-directory
ID: toolu_015o6k3RybJtaWgXcNTLtaEA

### path

<tool.toolu_015o6k3RybJtaWgXcNTLtaEA>
.
</tool.toolu_015o6k3RybJtaWgXcNTLtaEA>

### recursive

<tool.toolu_015o6k3RybJtaWgXcNTLtaEA>
true
</tool.toolu_015o6k3RybJtaWgXcNTLtaEA>

## TOOL RESULT:

ID: toolu_015o6k3RybJtaWgXcNTLtaEA

<tool.toolu_015o6k3RybJtaWgXcNTLtaEA>
./:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
-rw-r--r--       158  .dir-locals.el
-rw-r--r--        55  .elpaignore
drwxr-xr-x  (dir)  .git
drwxr-xr-x  (dir)  .github
-rw-r--r--         5  .gitignore
-rw-r--r--      1071  LICENSE
-rw-r--r--      3218  README.md
-rw-r--r--    308449  chat.ai
-rw-r--r--      2242  debug-citations-immediate.el
-rw-r--r--      1837  debug-citations-verbose.el
-rw-r--r--     37877  fix-tests.grgr
-rw-r--r--     16561  greger-client.el
-rw-r--r--     65172  greger-parser.el
-rw-r--r--     53804  greger-stdlib.el
-rw-r--r--     15226  greger-tools.el
-rw-r--r--      4171  greger-web.el
-rw-r--r--     39060  greger.el
drwxr-xr-x  (dir)  recipes
drwxr-xr-x  (dir)  script
drwxr-xr-x  (dir)  test
-rw-r--r--      1736  test-citations-output.el

./.github/:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
drwxr-xr-x  (dir)  workflows

./.github/workflows/:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
-rw-r--r--      1376  ci.yml

./recipes/:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
-rw-r--r--        88  greger

./script/:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
-rwxr-xr-x      1175  lint
-rwxr-xr-x      7486  test

./test/:
drwxr-xr-x  (dir)  .
drwxr-xr-x  (dir)  ..
-rw-r--r--     12348  request.json
-rw-r--r--     15332  test-end-to-end.el
-rw-r--r--      8035  test-greger-client.el
-rw-r--r--     63180  test-greger-parser.el
-rw-r--r--     37616  test-greger-stdlib.el
-rw-r--r--     35810  test-greger-tools.el
-rw-r--r--     19693  test-greger.el
</tool.toolu_015o6k3RybJtaWgXcNTLtaEA>

## ASSISTANT:

Let me examine the current parser implementation to see what's already been started:

## TOOL USE:

Name: read-file
ID: toolu_01H3AwPhJDjRiWTGog79nkzD

### path

<tool.toolu_01H3AwPhJDjRiWTGog79nkzD>
greger-parser.el
</tool.toolu_01H3AwPhJDjRiWTGog79nkzD>

### include-line-numbers

<tool.toolu_01H3AwPhJDjRiWTGog79nkzD>
true
</tool.toolu_01H3AwPhJDjRiWTGog79nkzD>

## TOOL RESULT:

ID: toolu_01H3AwPhJDjRiWTGog79nkzD

<tool.toolu_01H3AwPhJDjRiWTGog79nkzD>
   1: ;;; greger-parser.el --- Parser for greger dialog format -*- lexical-binding: t -*-
   2: 
   3: ;; Copyright (C) 2023 Andreas Jansson
   4: 
   5: ;; Author: Andreas Jansson <andreas@jansson.me.uk>
   6: ;; Version: 0.1.0
   7: ;; URL: https://github.com/andreasjansson/greger.el
   8: ;; SPDX-License-Identifier: MIT
   9: 
  10: ;; Permission is hereby granted, free of charge, to any person obtaining a copy
  11: ;; of this software and associated documentation files (the "Software"), to deal
  12: ;; in the Software without restriction, including without limitation the rights
  13: ;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  14: ;; copies of the Software, and to permit persons to whom the Software is
  15: ;; furnished to do so, subject to the following conditions:
  16: 
  17: ;; The above copyright notice and this permission notice shall be included in all
  18: ;; copies or substantial portions of the Software.
  19: 
  20: ;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  21: ;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  22: ;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  23: ;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  24: ;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  25: ;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  26: ;; SOFTWARE.
  27: 
  28: ;;; Commentary:
  29: ;; Parses markdown-style dialog format with sections like ## USER:, ## ASSISTANT:, etc.
  30: ;; Handles tool use, thinking blocks, and complex content structures.
  31: 
  32: ;;; Code:
  33: 
  34: (require 'json)
  35: (require 'cl-lib)
  36: (require 'greger-web)
  37: 
  38: ;; Section tag constants
  39: (defconst greger-parser-system-tag "## SYSTEM:")
  40: (defconst greger-parser-user-tag "## USER:")
  41: (defconst greger-parser-assistant-tag "## ASSISTANT:")
  42: (defconst greger-parser-thinking-tag "## THINKING:")
  43: (defconst greger-parser-citations-tag "## CITATIONS:")
  44: (defconst greger-parser-tool-use-tag "## TOOL USE:")
  45: (defconst greger-parser-tool-result-tag "## TOOL RESULT:")
  46: (defconst greger-parser-server-tool-use-tag "## SERVER TOOL USE:")
  47: (defconst greger-parser-server-tool-result-tag "## SERVER TOOL RESULT:")
  48: 
  49: ;;; Parser state structure
  50: 
  51: (cl-defstruct greger-parser-state
  52:   input
  53:   pos
  54:   length
  55:   debug
  56:   metadata)
  57: 
  58: (defun greger-parser--create-state (input &optional debug)
  59:   "Create a parser state for INPUT with optional DEBUG flag."
  60:   (make-greger-parser-state
  61:    :input (or input "")
  62:    :pos 0
  63:    :length (length (or input ""))
  64:    :debug debug
  65:    :metadata '()))
  66: 
  67: (defun greger-parser--debug (state format-string &rest args)
  68:   "Debug logging function using STATE.
  69: FORMAT-STRING is the format template and ARGS are the format arguments."
  70:   (when (greger-parser-state-debug state)
  71:     (message "[PARSER DEBUG] %s" (apply #'format format-string args))))
  72: 
  73: ;; Main parsing entry points
  74: 
  75: (defun greger-parser-parse-dialog (markdown &optional debug)
  76:   "Parse MARKDOWN into dialog format with optional DEBUG flag.
  77: Returns a plist with :messages and :metadata keys."
  78:   (if (or (null markdown) (string-empty-p (string-trim markdown)))
  79:       '(:messages () :metadata ())
  80:     (let ((state (greger-parser--create-state markdown debug)))
  81:       (condition-case err
  82:           (greger-parser--parse-document state)
  83:         (error
  84:          (greger-parser--debug state "Parse error: %s" (error-message-string err))
  85:          '(:messages () :metadata ()))))))
  86: 
  87: (defun greger-parser-dialog-to-markdown (dialog)
  88:   "Convert DIALOG to markdown format."
  89:   (if (null dialog)
  90:       ""
  91:     (mapconcat #'greger-parser--message-to-markdown dialog "\n\n")))
  92: 
  93: ;; Compatibility function for tests and existing code
  94: (defun greger-parser-parse-dialog-messages-only (markdown &optional debug)
  95:   "Parse MARKDOWN into dialog format, returning only the messages (old format).
  96: This is for backward compatibility with existing tests and code.
  97: DEBUG enables debug logging."
  98:   (let ((result (greger-parser-parse-dialog markdown debug)))
  99:     (plist-get result :messages)))
 100: 
 101: ;; Parser infrastructure
 102: 
 103: (defun greger-parser--at-end-p (state)
 104:   "True if at end of input in STATE."
 105:   (>= (greger-parser-state-pos state) (greger-parser-state-length state)))
 106: 
 107: (defun greger-parser--peek (state &optional offset)
 108:   "Peek at character at current position plus OFFSET in STATE."
 109:   (let ((pos (+ (greger-parser-state-pos state) (or offset 0))))
 110:     (if (and (>= pos 0) (< pos (greger-parser-state-length state)))
 111:         (aref (greger-parser-state-input state) pos)
 112:       nil)))
 113: 
 114: (defun greger-parser--advance (state &optional n)
 115:   "Advance position by N characters (default 1) in STATE."
 116:   (let ((old-pos (greger-parser-state-pos state)))
 117:     (setf (greger-parser-state-pos state)
 118:           (min (greger-parser-state-length state)
 119:                (+ (greger-parser-state-pos state) (or n 1))))
 120:     (greger-parser--debug state "Advanced from %d to %d" old-pos (greger-parser-state-pos state))))
 121: 
 122: (defun greger-parser--current-pos (state)
 123:   "Get current position from STATE."
 124:   (greger-parser-state-pos state))
 125: 
 126: (defun greger-parser--insert-content-at-pos (state content)
 127:   "Insert CONTENT into STATE at the current position and update length."
 128:   (let* ((pos (greger-parser-state-pos state))
 129:          (input (greger-parser-state-input state))
 130:          (before (substring input 0 pos))
 131:          (after (substring input pos))
 132:          (new-input (concat before content after)))
 133:     (setf (greger-parser-state-input state) new-input)
 134:     (setf (greger-parser-state-length state) (length new-input))))
 135: 
 136: (defun greger-parser--substring (state start &optional end)
 137:   "Get substring from START to END (or current position) in STATE."
 138:   (let ((input (greger-parser-state-input state))
 139:         (length (greger-parser-state-length state))
 140:         (current-pos (greger-parser-state-pos state)))
 141:     (if (and (>= start 0)
 142:              (<= start length)
 143:              (or (null end) (<= end length)))
 144:         (substring input start (or end current-pos))
 145:       "")))
 146: 
 147: (defun greger-parser--looking-at (state string)
 148:   "True if current position matches STRING in STATE."
 149:   (and string
 150:        (<= (+ (greger-parser-state-pos state) (length string)) (greger-parser-state-length state))
 151:        (string= (greger-parser--substring state (greger-parser-state-pos state)
 152:                                          (+ (greger-parser-state-pos state) (length string)))
 153:                 string)))
 154: 
 155: (defun greger-parser--at-triple-backticks (state)
 156:   "True if current position matches ``` at beginning of line in STATE."
 157:   (and (greger-parser--at-line-start-p state)
 158:        (greger-parser--looking-at state "```")))
 159: 
 160: ;; Character tests
 161: 
 162: (defun greger-parser--whitespace-p (char)
 163:   "True if CHAR is whitespace."
 164:   (and char (memq char '(?\s ?\t ?\n ?\r))))
 165: 
 166: (defun greger-parser--horizontal-whitespace-p (char)
 167:   "True if CHAR is horizontal whitespace."
 168:   (and char (memq char '(?\s ?\t))))
 169: 
 170: (defun greger-parser--newline-p (char)
 171:   "True if CHAR is newline."
 172:   (and char (eq char ?\n)))
 173: 
 174: ;; Navigation
 175: 
 176: (defun greger-parser--skip-whitespace (state)
 177:   "Skip all whitespace in STATE."
 178:   (let ((start-pos (greger-parser-state-pos state)))
 179:     (while (and (not (greger-parser--at-end-p state))
 180:                 (greger-parser--whitespace-p (greger-parser--peek state)))
 181:       (greger-parser--advance state))
 182:     (when (> (greger-parser-state-pos state) start-pos)
 183:       (greger-parser--debug state "Skipped whitespace from %d to %d" start-pos (greger-parser-state-pos state)))))
 184: 
 185: (defun greger-parser--skip-horizontal-whitespace (state)
 186:   "Skip spaces and tabs in STATE."
 187:   (while (and (not (greger-parser--at-end-p state))
 188:               (greger-parser--horizontal-whitespace-p (greger-parser--peek state)))
 189:     (greger-parser--advance state)))
 190: 
 191: (defun greger-parser--at-line-start-p (state)
 192:   "True if at start of line in STATE."
 193:   (or (= (greger-parser-state-pos state) 0)
 194:       (greger-parser--newline-p (greger-parser--peek state -1))))
 195: 
 196: (defun greger-parser--skip-to-line-end (state)
 197:   "Skip to end of current line in STATE."
 198:   (while (and (not (greger-parser--at-end-p state))
 199:               (not (greger-parser--newline-p (greger-parser--peek state))))
 200:     (greger-parser--advance state)))
 201: 
 202: (defun greger-parser--read-line (state)
 203:   "Read rest of current line in STATE."
 204:   (let ((start (greger-parser--current-pos state)))
 205:     (greger-parser--skip-to-line-end state)
 206:     (string-trim (greger-parser--substring state start))))
 207: 
 208: ;; Section tag handling
 209: 
 210: (defun greger-parser--section-tags ()
 211:   "List of all section tags."
 212:   (list greger-parser-system-tag
 213:         greger-parser-user-tag
 214:         greger-parser-assistant-tag
 215:         greger-parser-thinking-tag
 216:         greger-parser-citations-tag
 217:         greger-parser-tool-use-tag
 218:         greger-parser-tool-result-tag
 219:         greger-parser-server-tool-use-tag
 220:         greger-parser-server-tool-result-tag))
 221: 
 222: (defun greger-parser--find-section-tag (state)
 223:   "Find section tag at current position if at line start in STATE."
 224:   (when (greger-parser--at-line-start-p state)
 225:     (let ((tag (cl-find-if (lambda (tag) (greger-parser--looking-at state tag)) (greger-parser--section-tags))))
 226:       (greger-parser--debug state "Found section tag: %s at pos %d" tag (greger-parser-state-pos state))
 227:       tag)))
 228: 
 229: (defun greger-parser--consume-section-tag (state tag)
 230:   "Consume TAG and return it in STATE."
 231:   (when (greger-parser--looking-at state tag)
 232:     (greger-parser--debug state "Consuming tag: %s" tag)
 233:     (greger-parser--advance state (length tag))
 234:     tag))
 235: 
 236: ;; Code block detection and skipping
 237: 
 238: (defun greger-parser--skip-code-block (state)
 239:   "Skip triple-backtick code block in STATE."
 240:   (greger-parser--debug state "Skipping code block at pos %d" (greger-parser-state-pos state))
 241:   (greger-parser--advance state 3) ; Skip opening ```
 242:   (greger-parser--skip-to-line-end state) ; Skip language specifier
 243:   (when (greger-parser--newline-p (greger-parser--peek state))
 244:     (greger-parser--advance state))
 245: 
 246:   ;; Find closing ```
 247:   (while (and (not (greger-parser--at-end-p state))
 248:               (not (greger-parser--at-triple-backticks state)))
 249:     (greger-parser--advance state))
 250: 
 251:   ;; Skip closing ```
 252:   (when (greger-parser--at-triple-backticks state)
 253:     (greger-parser--advance state 3)))
 254: 
 255: (defun greger-parser--skip-inline-code (state)
 256:   "Skip inline code with double backticks in STATE."
 257:   (greger-parser--debug state "Skipping inline code at pos %d" (greger-parser-state-pos state))
 258:   (greger-parser--advance state 1) ; Skip opening `
 259:   (while (and (not (greger-parser--at-end-p state))
 260:               (not (greger-parser--looking-at state "`")))
 261:     (greger-parser--advance state))
 262:   (when (greger-parser--looking-at state "`")
 263:     (greger-parser--advance state 1)))
 264: 
 265: (defun greger-parser--skip-html-comment (state)
 266:   "Skip HTML comment in STATE."
 267:   (greger-parser--debug state "Skipping HTML comment at pos %d" (greger-parser-state-pos state))
 268:   (greger-parser--advance state 4) ; Skip <!--
 269:   (while (and (not (greger-parser--at-end-p state))
 270:               (not (greger-parser--looking-at state "-->")))
 271:     (greger-parser--advance state))
 272:   (when (greger-parser--looking-at state "-->")
 273:     (greger-parser--advance state 3)))
 274: 
 275: ;; Web URL text extraction (moved to greger-web.el)
 276: 
 277: ;; Include tag processing
 278: 
 279: (defun greger-parser--process-include-tag (state)
 280:   "Process an include tag and return the included content in STATE."
 281:   (greger-parser--debug state "Processing include tag at pos %d" (greger-parser-state-pos state))
 282:   (progn
 283:     ;; Parse the opening tag
 284:     (when (greger-parser--looking-at state "<include")
 285:       (greger-parser--advance state 8) ; Skip "<include"
 286:       (let ((has-code-attr nil))
 287:         ;; Check for optional "code" attribute
 288:         (greger-parser--skip-horizontal-whitespace state)
 289:         (when (greger-parser--looking-at state "code")
 290:           (setq has-code-attr t)
 291:           (greger-parser--advance state 4)
 292:           (greger-parser--skip-horizontal-whitespace state))
 293: 
 294:         ;; Skip to closing bracket of opening tag
 295:         (when (greger-parser--looking-at state ">")
 296:           (greger-parser--advance state 1)
 297: 
 298:           ;; Extract the file path
 299:           (let ((path-start (greger-parser--current-pos state)))
 300:             (when (greger-parser--find-closing-tag state "</include>")
 301:               (let ((file-path (string-trim (greger-parser--substring state path-start))))
 302:                 (greger-parser--advance state 10) ; Skip "</include>"
 303: 
 304:                 ;; Read and process the file
 305:                 (greger-parser--include-file state file-path has-code-attr)))))))))
 306: 
 307: (defun greger-parser--include-file (state file-path has-code-attr)
 308:   "Include a file's content, optionally formatting as code using STATE.
 309: Supports both local files and web URLs (http:// or https://).
 310: For local files without code attribute, inserts content into state for
 311: recursive parsing.  Returns nil when content is inserted, or the content
 312: string when it should be appended.
 313: FILE-PATH is the path to include and HAS-CODE-ATTR indicates code formatting."
 314:   (greger-parser--debug state "Including file: %s (code: %s)" file-path has-code-attr)
 315:   (condition-case err
 316:       (let ((content
 317:              (if (greger-web-is-web-url-p file-path)
 318:                  ;; Handle web URL
 319:                  (progn
 320:                    (greger-parser--debug state "Downloading content from URL: %s" file-path)
 321:                    (greger-web-text-from-url file-path t)) ; Use readability heuristics
 322:                ;; Handle local file
 323:                (with-temp-buffer
 324:                  (insert-file-contents file-path)
 325:                  (buffer-string)))))
 326: 
 327:         ;; Remove trailing newline from content if present
 328:         (when (and (> (length content) 0)
 329:                    (eq (aref content (1- (length content))) ?\n))
 330:           (setq content (substring content 0 -1)))
 331: 
 332:         (cond
 333:          ;; For files with code attribute or web URLs, return formatted content
 334:          ((or has-code-attr (greger-web-is-web-url-p file-path))
 335:           (if has-code-attr
 336:               (format "%s:\n```\n%s\n```" file-path content)
 337:             content))
 338:          ;; For local files without code attribute, insert content into state for recursive parsing
 339:          (t
 340:           (greger-parser--insert-content-at-pos state content)
 341:           nil))) ; Return nil to indicate content was inserted
 342:     (error
 343:      (greger-parser--debug state "Error reading %s %s: %s"
 344:                           (if (greger-web-is-web-url-p file-path) "URL" "file")
 345:                           file-path
 346:                           (error-message-string err))
 347:      ;; Return error message as content instead of failing silently
 348:      (format "[Error reading %s: %s]"
 349:              (if (greger-web-is-web-url-p file-path) "URL" "file")
 350:              file-path))))
 351: 
 352: (defun greger-parser--skip-include-tag (state)
 353:   "Skip include tag without processing it in STATE."
 354:   (greger-parser--debug state "Skipping include tag at pos %d" (greger-parser-state-pos state))
 355:   (greger-parser--advance state 8) ; Skip "<include"
 356: 
 357:   ;; Skip optional "code" attribute
 358:   (greger-parser--skip-horizontal-whitespace state)
 359:   (when (greger-parser--looking-at state "code")
 360:     (greger-parser--advance state 4)
 361:     (greger-parser--skip-horizontal-whitespace state))
 362: 
 363:   ;; Skip to closing bracket of opening tag
 364:   (when (greger-parser--looking-at state ">")
 365:     (greger-parser--advance state 1)
 366: 
 367:     ;; Skip to closing tag
 368:     (when (greger-parser--find-closing-tag state "</include>")
 369:       (greger-parser--advance state 10)))) ; Skip "</include>"
 370: 
 371: (defun greger-parser--process-safe-shell-commands-tag (state)
 372:   "Process a safe-shell-commands tag and return the list of commands in STATE."
 373:   (greger-parser--debug state "Processing safe-shell-commands tag at pos %d" (greger-parser-state-pos state))
 374:   (when (greger-parser--looking-at state "<safe-shell-commands>")
 375:     (greger-parser--advance state (length "<safe-shell-commands>")) ; Skip "<safe-shell-commands>"
 376: 
 377:     ;; Extract the commands content
 378:     (let ((content-start (greger-parser--current-pos state)))
 379:       (when (greger-parser--find-closing-tag state "</safe-shell-commands>")
 380:         (let ((commands-content (greger-parser--substring state content-start)))
 381:           (greger-parser--advance state (length "</safe-shell-commands>")) ; Skip "</safe-shell-commands>"
 382: 
 383:           ;; Parse commands - split by lines and filter empty ones
 384:           (let ((commands (delq nil
 385:                                (mapcar (lambda (line)
 386:                                         (let ((trimmed (string-trim line)))
 387:                                           (when (not (string-empty-p trimmed))
 388:                                             trimmed)))
 389:                                       (split-string commands-content "\n")))))
 390:             (greger-parser--debug state "Extracted safe shell commands: %s" commands)
 391:             commands))))))
 392: 
 393: ;; Content reading
 394: 
 395: (defun greger-parser--read-until-section-tag (state)
 396:   "Read characters until section tag, handling code blocks and include tags.
 397: STATE contains the parser state."
 398:   (let ((iterations 0)
 399:         (max-iterations (* (greger-parser-state-length state) 2))) ; Safety limit
 400:     (while (and (not (greger-parser--at-end-p state))
 401:                 (not (and (greger-parser--at-line-start-p state)
 402:                           (greger-parser--find-section-tag state)))
 403:                 (< iterations max-iterations))
 404:       (setq iterations (1+ iterations))
 405:       (let ((old-pos (greger-parser-state-pos state)))
 406:         (cond
 407:          ((greger-parser--at-triple-backticks state)
 408:           (greger-parser--skip-code-block state))
 409:          ((greger-parser--looking-at state "`")
 410:           (greger-parser--skip-inline-code state))
 411:          ((greger-parser--looking-at state "<!--")
 412:           (greger-parser--skip-html-comment state))
 413:          ((greger-parser--looking-at state "<include")
 414:           (greger-parser--skip-include-tag state))
 415:          (t
 416:           (greger-parser--advance state)))
 417:         ;; Safety check: ensure we're making progress
 418:         (when (= old-pos (greger-parser-state-pos state))
 419:           (greger-parser--debug state "No progress at pos %d, forcing advance" (greger-parser-state-pos state))
 420:           (greger-parser--advance state))))
 421:     (when (>= iterations max-iterations)
 422:       (greger-parser--debug state "Hit max iterations in read-until-section-tag")
 423:       (setf (greger-parser-state-pos state) (greger-parser-state-length state)))))
 424: 
 425: (defun greger-parser--read-until-section (state)
 426:   "Read content until next section in STATE."
 427:   (let ((start (greger-parser--current-pos state)))
 428:     (greger-parser--read-until-section-tag state)
 429:     (greger-parser--substring state start)))
 430: 
 431: (defun greger-parser--read-until-section-with-comment-removal (state)
 432:   "Read content until next section, removing HTML comments and processing tags.
 433: STATE contains the parser state."
 434:   (let ((result "")
 435:         (start (greger-parser--current-pos state))
 436:         (iterations 0)
 437:         (max-iterations (* (greger-parser-state-length state) 2))) ; Safety limit
 438:     (while (and (not (greger-parser--at-end-p state))
 439:                 (not (and (greger-parser--at-line-start-p state)
 440:                           (greger-parser--find-section-tag state)))
 441:                 (< iterations max-iterations))
 442:       (setq iterations (1+ iterations))
 443:       (let ((old-pos (greger-parser-state-pos state)))
 444:         (cond
 445:          ((greger-parser--at-triple-backticks state)
 446:           ;; Add content up to code block
 447:           (setq result (concat result (greger-parser--substring state start)))
 448:           (setq start (greger-parser--current-pos state))
 449:           (greger-parser--skip-code-block state)
 450:           ;; Add the code block
 451:           (setq result (concat result (greger-parser--substring state start)))
 452:           (setq start (greger-parser--current-pos state)))
 453:          ((greger-parser--looking-at state "`")
 454:           ;; Add content up to inline code
 455:           (setq result (concat result (greger-parser--substring state start)))
 456:           (setq start (greger-parser--current-pos state))
 457:           (greger-parser--skip-inline-code state)
 458:           ;; Add the inline code
 459:           (setq result (concat result (greger-parser--substring state start)))
 460:           (setq start (greger-parser--current-pos state)))
 461:          ((greger-parser--looking-at state "<!--")
 462:           ;; Add content up to comment, skip comment entirely
 463:           (setq result (concat result (greger-parser--substring state start)))
 464:           (greger-parser--skip-html-comment state)
 465:           (setq start (greger-parser--current-pos state)))
 466:          ((greger-parser--looking-at state "<include")
 467:           ;; Add content up to include tag
 468:           (setq result (concat result (greger-parser--substring state start)))
 469:           ;; Process the include tag
 470:           (let ((include-content (greger-parser--process-include-tag state)))
 471:             (if include-content
 472:                 ;; Content was returned (web URL or code), append it
 473:                 (setq result (concat result include-content))
 474:               ;; Content was inserted into state (local file), continue parsing from current position
 475:               nil))
 476:           (setq start (greger-parser--current-pos state)))
 477:          (t
 478:           (greger-parser--advance state)))
 479:         ;; Safety check: ensure we're making progress
 480:         (when (= old-pos (greger-parser-state-pos state))
 481:           (greger-parser--debug state "No progress at pos %d, forcing advance" (greger-parser-state-pos state))
 482:           (greger-parser--advance state))))
 483:     (when (>= iterations max-iterations)
 484:       (greger-parser--debug state "Hit max iterations in read-until-section-with-comment-removal")
 485:       (setf (greger-parser-state-pos state) (greger-parser-state-length state)))
 486:     ;; Add remaining content
 487:     (setq result (concat result (greger-parser--substring state start)))
 488:     result))
 489: 
 490: (defun greger-parser--read-until-section-with-metadata-extraction (state)
 491:   "Read content until next section, extracting metadata like safe-shell-commands.
 492: Returns a plist with :content and metadata keys.
 493: STATE contains the parser state."
 494:   (let ((result "")
 495:         (safe-shell-commands nil)
 496:         (start (greger-parser--current-pos state))
 497:         (iterations 0)
 498:         (max-iterations (* (greger-parser-state-length state) 2))) ; Safety limit
 499:     (while (and (not (greger-parser--at-end-p state))
 500:                 (not (and (greger-parser--at-line-start-p state)
 501:                           (greger-parser--find-section-tag state)))
 502:                 (< iterations max-iterations))
 503:       (setq iterations (1+ iterations))
 504:       (let ((old-pos (greger-parser-state-pos state)))
 505:         (cond
 506:          ((greger-parser--at-triple-backticks state)
 507:           ;; Add content up to code block
 508:           (setq result (concat result (greger-parser--substring state start)))
 509:           (setq start (greger-parser--current-pos state))
 510:           (greger-parser--skip-code-block state)
 511:           ;; Add the code block
 512:           (setq result (concat result (greger-parser--substring state start)))
 513:           (setq start (greger-parser--current-pos state)))
 514:          ((greger-parser--looking-at state "`")
 515:           ;; Add content up to inline code
 516:           (setq result (concat result (greger-parser--substring state start)))
 517:           (setq start (greger-parser--current-pos state))
 518:           (greger-parser--skip-inline-code state)
 519:           ;; Add the inline code
 520:           (setq result (concat result (greger-parser--substring state start)))
 521:           (setq start (greger-parser--current-pos state)))
 522:          ((greger-parser--looking-at state "<!--")
 523:           ;; Add content up to comment, skip comment entirely
 524:           (setq result (concat result (greger-parser--substring state start)))
 525:           (greger-parser--skip-html-comment state)
 526:           (setq start (greger-parser--current-pos state)))
 527:          ((greger-parser--looking-at state "<include")
 528:           ;; Add content up to include tag
 529:           (setq result (concat result (greger-parser--substring state start)))
 530:           ;; Process the include tag
 531:           (let ((include-content (greger-parser--process-include-tag state)))
 532:             (if include-content
 533:                 ;; Content was returned (web URL or code), append it
 534:                 (setq result (concat result include-content))
 535:               ;; Content was inserted into state (local file), continue parsing from current position
 536:               nil))
 537:           (setq start (greger-parser--current-pos state)))
 538:          ((greger-parser--looking-at state "<safe-shell-commands>")
 539:           ;; Add content up to safe-shell-commands tag (but don't include the tag itself)
 540:           (setq result (concat result (greger-parser--substring state start)))
 541:           ;; Process the safe-shell-commands tag
 542:           (let ((commands (greger-parser--process-safe-shell-commands-tag state)))
 543:             (when commands
 544:               (if safe-shell-commands
 545:                   (greger-parser--debug state "Warning: multiple <safe-shell-commands> tags found")
 546:                 (setq safe-shell-commands commands))))
 547:           ;; Reset start position for next content
 548:           (setq start (greger-parser--current-pos state)))
 549:          (t
 550:           (greger-parser--advance state)))
 551:         ;; Safety check: ensure we're making progress
 552:         (when (= old-pos (greger-parser-state-pos state))
 553:           (greger-parser--debug state "No progress at pos %d, forcing advance" (greger-parser-state-pos state))
 554:           (greger-parser--advance state))))
 555:     (when (>= iterations max-iterations)
 556:       (greger-parser--debug state "Hit max iterations in read-until-section-with-metadata-extraction")
 557:       (setf (greger-parser-state-pos state) (greger-parser-state-length state)))
 558:     ;; Add remaining content
 559:     (setq result (concat result (greger-parser--substring state start)))
 560: 
 561:     ;; Return result with metadata
 562:     (let ((trimmed-content (when (and result (not (string-empty-p (string-trim result))))
 563:                             (string-trim result))))
 564:       (list :content trimmed-content
 565:             :safe-shell-commands safe-shell-commands))))
 566: 
 567: (defun greger-parser--parse-section-content (state)
 568:   "Parse content until next section, skipping HTML comments.
 569: STATE contains the parser state."
 570:   (greger-parser--skip-whitespace state)
 571:   (let ((content (greger-parser--read-until-section-with-comment-removal state)))
 572:     (when (and content (not (string-empty-p (string-trim content))))
 573:       (string-trim content))))
 574: 
 575: (defun greger-parser--parse-section-content-with-metadata (state)
 576:   "Parse content until next section, extracting metadata like safe-shell-commands.
 577: Returns a plist with :content and metadata keys like :safe-shell-commands.
 578: STATE contains the parser state."
 579:   (greger-parser--skip-whitespace state)
 580:   (let ((result (greger-parser--read-until-section-with-metadata-extraction state)))
 581:     result))
 582: 
 583: ;; High-level parsing
 584: 
 585: (defun greger-parser--parse-document (state)
 586:   "Parse entire document using STATE.
 587: Returns a plist with :messages and :metadata keys."
 588:   (greger-parser--skip-whitespace state)
 589:   (if (greger-parser--at-end-p state)
 590:       '(:messages () :metadata ())
 591:     (let ((sections '())
 592:           (metadata '())
 593:           (iterations 0)
 594:           (max-iterations 1000)) ; Safety limit
 595:       ;; Handle untagged content at start
 596:       (let ((untagged (greger-parser--parse-untagged-content state)))
 597:         (when untagged
 598:           (push untagged sections)))
 599: 
 600:       ;; Parse tagged sections
 601:       (while (and (not (greger-parser--at-end-p state))
 602:                   (< iterations max-iterations))
 603:         (setq iterations (1+ iterations))
 604:         (let ((old-pos (greger-parser-state-pos state)))
 605:           (greger-parser--skip-whitespace state)
 606:           (when (not (greger-parser--at-end-p state))
 607:             (let ((section-result (greger-parser--parse-section state)))
 608:               (when section-result
 609:                 (greger-parser--debug state "Section result: %s" section-result)
 610:                 (cond
 611:                  ;; Handle metadata
 612:                  ((and (listp section-result) (eq (car section-result) :metadata))
 613:                   (greger-parser--debug state "Found metadata section")
 614:                   (setq metadata (append metadata (cdr section-result))))
 615:                  ;; Handle citations data - store for later processing
 616:                  ((and (listp section-result) (eq (plist-get section-result :type) :citations-data))
 617:                   (greger-parser--debug state "Found citations data, storing for later processing")
 618:                   (setq metadata (append metadata (list :pending-citations (plist-get section-result :citations)))))
 619:                  ;; Regular message
 620:                  (t
 621:                   (greger-parser--debug state "Regular message section")
 622:                   (push section-result sections))))))
 623:           ;; Safety check: ensure we're making progress
 624:           (when (= old-pos (greger-parser-state-pos state))
 625:             (greger-parser--debug state "No progress in document parsing at pos %d, forcing end" (greger-parser-state-pos state))
 626:             (setf (greger-parser-state-pos state) (greger-parser-state-length state)))))
 627: 
 628:       (when (>= iterations max-iterations)
 629:         (greger-parser--debug state "Hit max iterations in parse-document"))
 630: 
 631:       ;; Combine metadata from section returns and parser state
 632:       (let* ((combined-metadata (append metadata (greger-parser-state-metadata state)))
 633:              (merged-messages (greger-parser--merge-consecutive-messages (reverse sections)))
 634:              (pending-citations (plist-get combined-metadata :pending-citations)))
 635:         ;; Apply pending citations if any
 636:         (when pending-citations
 637:           (greger-parser--apply-citations-to-messages merged-messages pending-citations)
 638:           ;; Remove pending citations from metadata since they've been applied
 639:           (setq combined-metadata (greger-parser--remove-from-plist combined-metadata :pending-citations)))
 640:         (list :messages merged-messages
 641:               :metadata combined-metadata)))))
 642: 
 643: (defun greger-parser--parse-untagged-content (state)
 644:   "Parse content before first section tag using STATE."
 645:   (let ((content (greger-parser--parse-section-content state)))
 646:     (when content
 647:       (greger-parser--create-user-message content))))
 648: 
 649: (defun greger-parser--parse-section (state)
 650:   "Parse a section starting with a tag using STATE."
 651:   (let ((tag (greger-parser--find-section-tag state)))
 652:     (when tag
 653:       (greger-parser--consume-section-tag state tag)
 654:       (cond
 655:        ((string= tag greger-parser-system-tag)
 656:         (greger-parser--parse-system-section state))
 657:        ((string= tag greger-parser-user-tag)
 658:         (greger-parser--parse-user-section state))
 659:        ((string= tag greger-parser-assistant-tag)
 660:         (greger-parser--parse-assistant-section state))
 661:        ((string= tag greger-parser-thinking-tag)
 662:         (greger-parser--parse-thinking-section state))
 663:        ((string= tag greger-parser-citations-tag)
 664:         (greger-parser--parse-citations-section state))
 665:        ((string= tag greger-parser-tool-use-tag)
 666:         (greger-parser--parse-tool-use-section state))
 667:        ((string= tag greger-parser-tool-result-tag)
 668:         (greger-parser--parse-tool-result-section state))
 669:        ((string= tag greger-parser-server-tool-use-tag)
 670:         (greger-parser--parse-server-tool-use-section state))
 671:        ((string= tag greger-parser-server-tool-result-tag)
 672:         (greger-parser--parse-server-tool-result-section state))))))
 673: 
 674: ;; Section parsers
 675: 
 676: (defun greger-parser--parse-user-section (state)
 677:   "Parse USER section using STATE."
 678:   (let ((content (greger-parser--parse-section-content state)))
 679:     (when content
 680:       (greger-parser--create-user-message content))))
 681: 
 682: (defun greger-parser--parse-assistant-section (state)
 683:   "Parse ASSISTANT section using STATE."
 684:   (let ((content (greger-parser--parse-section-content state)))
 685:     (when content
 686:       (greger-parser--create-assistant-message content))))
 687: 
 688: (defun greger-parser--parse-system-section (state)
 689:   "Parse SYSTEM section using STATE.
 690: Returns either a system message, metadata, or both."
 691:   (let ((content (greger-parser--parse-section-content-with-metadata state)))
 692:     (cond
 693:      ;; If we extracted safe-shell-commands and no meaningful content, generate system message with safe commands text
 694:      ((and (plist-get content :safe-shell-commands)
 695:            (not (plist-get content :content)))
 696:       (let ((safe-commands-text (greger-parser--generate-safe-shell-commands-text
 697:                                 (plist-get content :safe-shell-commands))))
 698:         ;; Store metadata for later extraction and return system message with generated text
 699:         (setf (greger-parser-state-metadata state)
 700:               (append (or (greger-parser-state-metadata state) '())
 701:                       (list :safe-shell-commands (plist-get content :safe-shell-commands))))
 702:         (greger-parser--create-system-message safe-commands-text)))
 703: 
 704:      ;; If we have both content and safe-shell-commands, combine them
 705:      ((and (plist-get content :safe-shell-commands)
 706:            (plist-get content :content))
 707:       (greger-parser--debug state "Found safe-shell-commands with system content - both will be processed")
 708:       ;; Store metadata for later extraction and return system message with combined content
 709:       (setf (greger-parser-state-metadata state)
 710:             (append (or (greger-parser-state-metadata state) '())
 711:                     (list :safe-shell-commands (plist-get content :safe-shell-commands))))
 712:       (let ((safe-commands-text (greger-parser--generate-safe-shell-commands-text
 713:                                 (plist-get content :safe-shell-commands)))
 714:             (original-content (plist-get content :content)))
 715:         (greger-parser--create-system-message
 716:          (if safe-commands-text
 717:              (concat original-content "\n\n" safe-commands-text)
 718:            original-content))))
 719: 
 720:      ;; Just regular content
 721:      ((plist-get content :content)
 722:       (greger-parser--create-system-message (plist-get content :content)))
 723: 
 724:      ;; No content
 725:      (t nil))))
 726: 
 727: (defun greger-parser--parse-thinking-section (state)
 728:   "Parse THINKING section using STATE."
 729:   (let ((content (greger-parser--parse-section-content state)))
 730:     (when content
 731:       (greger-parser--create-thinking-message content))))
 732: 
 733: (defun greger-parser--parse-citations-section (state)
 734:   "Parse CITATIONS section using STATE.
 735: Returns parsed citation data that should be merged with the previous assistant message."
 736:   (let ((content (greger-parser--parse-section-content state)))
 737:     (when content
 738:       ;; Parse the citations from the markdown content
 739:       (let ((parsed-citations (greger-parser--parse-citations-content content)))
 740:         ;; Return a special marker indicating this contains citation data
 741:         ;; This will be handled specially in the document parsing
 742:         (list :type :citations-data :citations parsed-citations)))))
 743: 
 744: (defun greger-parser--parse-citations-content (content)
 745:   "Parse citations from markdown CONTENT and return list of citation objects."
 746:   (let ((citations '())
 747:         (lines (split-string content "\n"))
 748:         (current-citation nil)
 749:         (current-url nil))
 750:     (dolist (line lines)
 751:       (cond
 752:        ;; URL heading: ### https://example.com
 753:        ((string-match "^### \\(https?://[^\s]+\\)" line)
 754:         ;; Save previous citation if any
 755:         (when current-citation
 756:           (push current-citation citations))
 757:         ;; Start new citation
 758:         (setq current-url (match-string 1 line))
 759:         (setq current-citation (list (cons 'type "web_search_result_location")
 760:                                    (cons 'url current-url))))
 761:        ;; Title: ...
 762:        ((and current-citation (string-match "^Title: \\(.*\\)" line))
 763:         (push (cons 'title (match-string 1 line)) current-citation))
 764:        ;; Cited text: ...
 765:        ((and current-citation (string-match "^Cited text: \\(.*\\)" line))
 766:         (push (cons 'cited_text (match-string 1 line)) current-citation))
 767:        ;; Encrypted index: ...
 768:        ((and current-citation (string-match "^Encrypted index: \\(.*\\)" line))
 769:         (push (cons 'encrypted_index (match-string 1 line)) current-citation))))
 770:     ;; Add the last citation
 771:     (when current-citation
 772:       (push current-citation citations))
 773:     (reverse citations)))
 774: 
 775: (defun greger-parser--merge-citations-with-last-assistant (sections citations)
 776:   "Merge CITATIONS with the last assistant message in SECTIONS list.
 777: Modifies the sections list in-place."
 778:   (when (and sections citations)
 779:     (let ((last-msg (car sections)))
 780:       (when (and last-msg (string= "assistant" (alist-get 'role last-msg)))
 781:         ;; Find text blocks in the content and add citations to them
 782:         (let ((content (alist-get 'content last-msg)))
 783:           (when (listp content)
 784:             ;; Look for text blocks and add citations
 785:             (greger-parser--add-citations-to-content-blocks content citations)))))))
 786: 
 787: (defun greger-parser--add-citations-to-content-blocks (content-blocks citations)
 788:   "Add CITATIONS to appropriate text blocks in CONTENT-BLOCKS.
 789: Splits text blocks at <cite> boundaries and adds citations to cited portions."
 790:   (let ((i 0))
 791:     (while (< i (length content-blocks))
 792:       (let ((block (nth i content-blocks)))
 793:         (when (and (listp block) (string= "text" (alist-get 'type block)))
 794:           (let ((text (alist-get 'text block)))
 795:             ;; Check if text contains <cite> tags - if so, split and process
 796:             (when (and text (string-match-p "<cite>" text))
 797:               (let ((split-blocks (greger-parser--split-text-with-citations text citations)))
 798:                 ;; Replace the current block with the split blocks
 799:                 (setcdr (nthcdr (1- i) content-blocks)
 800:                         (append split-blocks (nthcdr (1+ i) content-blocks)))
 801:                 ;; Skip over the newly inserted blocks
 802:                 (setq i (+ i (length split-blocks)))
 803:                 ;; Continue without incrementing i again
 804:                 (setq i (1- i)))))))
 805:       (setq i (1+ i)))))
 806: 
 807: (defun greger-parser--apply-citations-to-messages (messages citations)
 808:   "Apply CITATIONS to the last assistant message in MESSAGES that contains <cite> tags."
 809:   ;; Find the last assistant message and apply citations to it
 810:   (dolist (message messages)
 811:     (when (string= "assistant" (alist-get 'role message))
 812:       (let ((content (alist-get 'content message)))
 813:         (cond
 814:          ;; String content - check for <cite> tags and process
 815:          ((stringp content)
 816:           (when (string-match-p "<cite>" content)
 817:             ;; Convert string with cite tags to text blocks
 818:             (let ((text-blocks (greger-parser--split-text-with-citations content citations)))
 819:               (setcdr (assq 'content message) text-blocks))))
 820:          ;; List content - process each content block
 821:          ((listp content)
 822:           (greger-parser--add-citations-to-content-blocks content citations)))))))
 823: 
 824: (defun greger-parser--remove-from-plist (plist key)
 825:   "Remove KEY from PLIST and return the new plist."
 826:   (let ((result '())
 827:         (skip-next nil))
 828:     (while plist
 829:       (if skip-next
 830:           (setq skip-next nil)
 831:         (if (eq (car plist) key)
 832:             (setq skip-next t)
 833:           (push (car plist) result)))
 834:       (setq plist (cdr plist)))
 835:     (reverse result)))
 836: 
 837: (defun greger-parser--remove-cite-tags (text)
 838:   "Remove <cite> and </cite> tags from TEXT."
 839:   (let ((result text))
 840:     (setq result (replace-regexp-in-string "<cite>" "" result))
 841:     (setq result (replace-regexp-in-string "</cite>" "" result))
 842:     result))
 843: 
 844: (defun greger-parser--split-text-with-citations (text citations)
 845:   "Split TEXT at <cite> boundaries, creating separate text blocks.
 846: Returns a list of text blocks, with citations attached to cited portions."
 847:   (let ((result '())
 848:         (pos 0)
 849:         (len (length text)))
 850:     (while (< pos len)
 851:       (let ((cite-start (string-match "<cite>" text pos)))
 852:         (if cite-start
 853:             (progn
 854:               ;; Add text before the cite tag (if any)
 855:               (when (> cite-start pos)
 856:                 (push `((type . "text")
 857:                         (text . ,(substring text pos cite-start)))
 858:                       result))
 859:               ;; Find the end of the cite tag
 860:               (let ((cite-end (string-match "</cite>" text cite-start)))
 861:                 (if cite-end
 862:                     (progn
 863:                       ;; Extract the cited text (without the tags)
 864:                       (let ((cited-text (substring text (+ cite-start 6) cite-end)))
 865:                         (push `((type . "text")
 866:                                 (text . ,cited-text)
 867:                                 (citations . ,citations))
 868:                               result))
 869:                       ;; Move past the closing tag
 870:                       (setq pos (+ cite-end 7)))
 871:                   ;; No closing tag found, treat rest as regular text
 872:                   (push `((type . "text")
 873:                           (text . ,(substring text pos)))
 874:                         result)
 875:                   (setq pos len))))
 876:           ;; No more cite tags, add remaining text
 877:           (when (< pos len)
 878:             (push `((type . "text")
 879:                     (text . ,(substring text pos)))
 880:                   result))
 881:           (setq pos len))))
 882:     (reverse result)))
 883: 
 884: (defun greger-parser--parse-tool-use-section (state)
 885:   "Parse TOOL USE section using STATE."
 886:   (greger-parser--skip-whitespace state)
 887:   (let ((name (greger-parser--parse-name-line state))
 888:         (id (greger-parser--parse-id-line state))
 889:         (input (greger-parser--parse-tool-input state)))
 890:     (when (and name id)
 891:       (greger-parser--create-tool-use-message name id input))))
 892: 
 893: (defun greger-parser--parse-tool-result-section (state)
 894:   "Parse TOOL RESULT section using STATE."
 895:   (greger-parser--skip-whitespace state)
 896:   (let ((id (greger-parser--parse-id-line state))
 897:         (content (greger-parser--parse-tool-result-content state)))
 898:     (when id
 899:       (greger-parser--create-tool-result-message id content))))
 900: 
 901: (defun greger-parser--parse-server-tool-use-section (state)
 902:   "Parse SERVER TOOL USE section using STATE."
 903:   (greger-parser--skip-whitespace state)
 904:   (let ((name (greger-parser--parse-name-line state))
 905:         (id (greger-parser--parse-id-line state))
 906:         (input (greger-parser--parse-server-tool-input state)))
 907:     (when (and name id)
 908:       (greger-parser--create-server-tool-use-message name id input))))
 909: 
 910: (defun greger-parser--parse-server-tool-result-section (state)
 911:   "Parse SERVER TOOL RESULT section using STATE."
 912:   (greger-parser--skip-whitespace state)
 913:   (let ((id (greger-parser--parse-id-line state))
 914:         (content (greger-parser--parse-server-tool-result-content state)))
 915:     (when id
 916:       (greger-parser--create-server-tool-result-message id content))))
 917: 
 918: ;; Tool parsing helpers
 919: 
 920: (defun greger-parser--parse-name-line (state)
 921:   "Parse \='Name: value\=' line using STATE."
 922:   (when (greger-parser--looking-at state "Name:")
 923:     (greger-parser--advance state 5)
 924:     (greger-parser--skip-horizontal-whitespace state)
 925:     (greger-parser--read-line state)))
 926: 
 927: (defun greger-parser--parse-id-line (state)
 928:   "Parse \='ID: value\=' line using STATE."
 929:   (greger-parser--skip-whitespace state)
 930:   (when (greger-parser--looking-at state "ID:")
 931:     (greger-parser--advance state 3)
 932:     (greger-parser--skip-horizontal-whitespace state)
 933:     (greger-parser--read-line state)))
 934: 
 935: (defun greger-parser--parse-tool-input (state)
 936:   "Parse tool input parameters using STATE."
 937:   (let ((params '())
 938:         (iterations 0)
 939:         (max-iterations 100)) ; Safety limit
 940:     (greger-parser--skip-whitespace state)
 941:     (while (and (greger-parser--can-parse-parameter-p state)
 942:                 (< iterations max-iterations))
 943:       (setq iterations (1+ iterations))
 944:       (let ((old-pos (greger-parser-state-pos state))
 945:             (param (greger-parser--parse-tool-parameter state)))
 946:         (when param
 947:           (push param params))
 948:         (greger-parser--skip-whitespace state)
 949:         ;; Safety check: ensure we're making progress
 950:         (when (= old-pos (greger-parser-state-pos state))
 951:           (greger-parser--debug state "No progress in tool input parsing at pos %d, forcing end" (greger-parser-state-pos state))
 952:           (setf (greger-parser-state-pos state) (greger-parser-state-length state)))))
 953:     (when (>= iterations max-iterations)
 954:       (greger-parser--debug state "Hit max iterations in parse-tool-input"))
 955:     (reverse params)))
 956: 
 957: (defun greger-parser--can-parse-parameter-p (state)
 958:   "Check if we can parse a parameter using STATE."
 959:   (and (not (greger-parser--at-end-p state))
 960:        (not (and (greger-parser--at-line-start-p state)
 961:                  (greger-parser--find-section-tag state)))
 962:        (greger-parser--at-line-start-p state)
 963:        (greger-parser--looking-at state "###")))
 964: 
 965: (defun greger-parser--parse-tool-parameter (state)
 966:   "Parse single tool parameter using STATE."
 967:   (when (greger-parser--looking-at state "###")
 968:     (greger-parser--advance state 3)
 969:     (greger-parser--skip-horizontal-whitespace state)
 970:     (let ((name (greger-parser--read-line state)))
 971:       (greger-parser--skip-whitespace state)
 972:       (let ((value (greger-parser--parse-tool-value state)))
 973:         (when (and name (not (string-empty-p name)))
 974:           (cons (intern name) (greger-parser--convert-value (or value ""))))))))
 975: 
 976: (defun greger-parser--parse-tool-value (state)
 977:   "Parse tool parameter value in XML-style tags using STATE."
 978:   (when (greger-parser--looking-at state "<tool.")
 979:     (let ((tag-start (greger-parser--current-pos state)))
 980:       ;; Find end of opening tag
 981:       (greger-parser--skip-to-closing-angle state)
 982:       (when (eq (greger-parser--peek state) ?>)
 983:         (let* ((opening-tag (greger-parser--substring state tag-start (+ (greger-parser--current-pos state) 1)))
 984:                (closing-tag (greger-parser--make-closing-tag opening-tag)))
 985:           (greger-parser--advance state) ; Skip >
 986:           (greger-parser--skip-whitespace state)
 987: 
 988:           (let ((content-start (greger-parser--current-pos state)))
 989:             (if (greger-parser--find-closing-tag state closing-tag)
 990:                 (let ((content (greger-parser--substring state content-start)))
 991:                   (greger-parser--advance state (length closing-tag))
 992:                   (greger-parser--normalize-tool-content content))
 993:               ;; If no closing tag found, consume to end of section
 994:               (let ((content (greger-parser--read-until-section state)))
 995:                 (greger-parser--normalize-tool-content content)))))))))
 996: 
 997: (defun greger-parser--skip-to-closing-angle (state)
 998:   "Skip to closing angle bracket using STATE."
 999:   (let ((iterations 0)
1000:         (max-iterations 1000)) ; Safety limit
1001:     (while (and (not (greger-parser--at-end-p state))
1002:                 (not (eq (greger-parser--peek state) ?>))
1003:                 (< iterations max-iterations))
1004:       (setq iterations (1+ iterations))
1005:       (greger-parser--advance state))
1006:     (when (>= iterations max-iterations)
1007:       (greger-parser--debug state "Hit max iterations in skip-to-closing-angle"))))
1008: 
1009: (defun greger-parser--make-closing-tag (opening-tag)
1010:   "Make closing tag from OPENING-TAG."
1011:   (concat "</" (substring opening-tag 1)))
1012: 
1013: (defun greger-parser--find-closing-tag (state closing-tag)
1014:   "Find CLOSING-TAG, treating all content inside as raw text using STATE."
1015:   (let ((found nil)
1016:         (iterations 0)
1017:         (max-iterations (* (greger-parser-state-length state) 2))) ; Safety limit
1018:     (while (and (not found)
1019:                 (not (greger-parser--at-end-p state))
1020:                 (< iterations max-iterations))
1021:       (setq iterations (1+ iterations))
1022:       (if (greger-parser--looking-at state closing-tag)
1023:           (setq found t)
1024:         (greger-parser--advance state)))
1025:     (when (>= iterations max-iterations)
1026:       (greger-parser--debug state "Hit max iterations in find-closing-tag"))
1027:     found))
1028: 
1029: (defun greger-parser--parse-tool-result-content (state)
1030:   "Parse tool result content using STATE."
1031:   (greger-parser--skip-whitespace state)
1032:   (or (greger-parser--parse-tool-value state) ""))
1033: 
1034: (defun greger-parser--parse-server-tool-input (state)
1035:   "Parse server tool input parameters using STATE."
1036:   ;; Server tools use the same parameter format as regular tools
1037:   (greger-parser--parse-tool-input state))
1038: 
1039: (defun greger-parser--parse-server-tool-result-content (state)
1040:   "Parse server tool result content using STATE."
1041:   ;; Server tool results use the same format as regular tool results
1042:   (greger-parser--parse-tool-result-content state))
1043: 
1044: (defun greger-parser--normalize-tool-content (content)
1045:   "Normalize tool CONTENT by trimming outer newlines."
1046:   (if (string-empty-p content)
1047:       ""
1048:     (let ((result content))
1049:       ;; Remove leading newline
1050:       (when (and (> (length result) 0)
1051:                  (eq (aref result 0) ?\n))
1052:         (setq result (substring result 1)))
1053:       ;; Remove trailing newline
1054:       (when (and (> (length result) 0)
1055:                  (eq (aref result (1- (length result))) ?\n))
1056:         (setq result (substring result 0 -1)))
1057:       result)))
1058: 
1059: (defun greger-parser--convert-value (str)
1060:   "Convert STR to appropriate Elisp value."
1061:   (let ((trimmed (string-trim str)))
1062:     (cond
1063:      ((string= trimmed "true") t)
1064:      ((string= trimmed "false") nil)
1065:      ((string-match-p "^-?[0-9]+$" trimmed)
1066:       (string-to-number trimmed))
1067:      ((string-match-p "^-?[0-9]*\\.[0-9]+$" trimmed)
1068:       (string-to-number trimmed))
1069:      ((and (string-prefix-p "[" trimmed) (string-suffix-p "]" trimmed))
1070:       (greger-parser--parse-json-array trimmed))
1071:      ((and (string-prefix-p "{" trimmed) (string-suffix-p "}" trimmed))
1072:       (greger-parser--parse-json-object trimmed))
1073:      (t trimmed))))
1074: 
1075: (defun greger-parser--parse-json-array (str)
1076:   "Parse JSON array STR."
1077:   (condition-case nil
1078:       (json-read-from-string str)
1079:     (error str)))
1080: 
1081: (defun greger-parser--parse-json-object (str)
1082:   "Parse JSON object STR."
1083:   (condition-case nil
1084:       (let ((parsed (json-read-from-string str)))
1085:         (mapcar (lambda (pair)
1086:                   (cons (intern (symbol-name (car pair))) (cdr pair)))
1087:                 parsed))
1088:     (error str)))
1089: 
1090: ;; Message creation
1091: 
1092: (defun greger-parser--create-user-message (content)
1093:   "Create user message with CONTENT."
1094:   `((role . "user") (content . ,content)))
1095: 
1096: (defun greger-parser--create-assistant-message (content)
1097:   "Create assistant message with CONTENT."
1098:   `((role . "assistant") (content . ,content)))
1099: 
1100: (defun greger-parser--create-system-message (content)
1101:   "Create system message with CONTENT."
1102:   `((role . "system") (content . ,content)))
1103: 
1104: (defun greger-parser--generate-safe-shell-commands-text (commands)
1105:   "Generate descriptive text for safe shell COMMANDS list."
1106:   (when commands
1107:     (concat "You can run arbitrary shell commands with the shell-command tool, but the following are safe shell commands that will run without requiring user confirmation:\n\n"
1108:             (mapconcat (lambda (cmd) (format "* `%s`" cmd)) commands "\n"))))
1109: 
1110: (defun greger-parser--create-thinking-message (content)
1111:   "Create thinking message with CONTENT."
1112:   `((role . "assistant")
1113:     (content . (((type . "thinking") (thinking . ,content))))))
1114: 
1115: (defun greger-parser--create-tool-use-message (name id input)
1116:   "Create tool use message with NAME, ID and INPUT."
1117:   `((role . "assistant")
1118:     (content . (((type . "tool_use")
1119:                  (id . ,id)
1120:                  (name . ,name)
1121:                  (input . ,input))))))
1122: 
1123: (defun greger-parser--create-tool-result-message (id content)
1124:   "Create tool result message with ID and CONTENT."
1125:   `((role . "user")
1126:     (content . (((type . "tool_result")
1127:                  (tool_use_id . ,id)
1128:                  (content . ,content))))))
1129: 
1130: (defun greger-parser--create-server-tool-use-message (name id input)
1131:   "Create server tool use message with NAME, ID and INPUT."
1132:   `((role . "assistant")
1133:     (content . (((type . "server_tool_use")
1134:                  (id . ,id)
1135:                  (name . ,name)
1136:                  (input . ,input))))))
1137: 
1138: (defun greger-parser--create-server-tool-result-message (id content)
1139:   "Create server tool result message with ID and CONTENT."
1140:   (let ((result-type (if (and (stringp content)
1141:                               (string-match-p "\"type\"[[:space:]]*:[[:space:]]*\"web_search_result\"" content))
1142:                          "web_search_tool_result"
1143:                        "server_tool_result")))
1144:     (let ((parsed-content
1145:            (if (stringp content)
1146:                (greger-parser--parse-json-content content)
1147:              content)))
1148:       `((role . "assistant")
1149:         (content . (((type . ,result-type)
1150:                      (tool_use_id . ,id)
1151:                      (content . ,parsed-content))))))))
1152: 
1153: (defun greger-parser--parse-json-content (content)
1154:   "Parse JSON CONTENT from string to structured data.
1155: Falls back to original content if parsing fails."
1156:   (condition-case err
1157:       (let ((parsed (json-read-from-string content)))
1158:         ;; Convert parsed JSON to alist format expected by the parser
1159:         (if (vectorp parsed)
1160:             ;; Handle arrays
1161:             (mapcar (lambda (item)
1162:                       (if (listp item)
1163:                           (mapcar (lambda (pair)
1164:                                     (cons (intern (symbol-name (car pair))) (cdr pair)))
1165:                                   item)
1166:                         item))
1167:                     parsed)
1168:           ;; Handle objects
1169:           (if (listp parsed)
1170:               (mapcar (lambda (pair)
1171:                         (cons (intern (symbol-name (car pair))) (cdr pair)))
1172:                       parsed)
1173:             ;; Handle primitive values
1174:             parsed)))
1175:     (error
1176:      ;; If parsing fails, return the content as-is
1177:      content)))
1178: 
1179: (defun greger-parser--create-citations-message (content)
1180:   "Create citations message with CONTENT."
1181:   `((role . "assistant")
1182:     (content . (((type . "citations") (citations . ,content))))))
1183: 
1184: ;; Message merging
1185: 
1186: (defun greger-parser--merge-consecutive-messages (messages)
1187:   "Merge consecutive MESSAGES with same role."
1188:   (if (null messages)
1189:       '()
1190:     (let ((result (list (car messages))))
1191:       (dolist (msg (cdr messages))
1192:         (let* ((last (car result))
1193:                (last-role (alist-get 'role last))
1194:                (curr-role (alist-get 'role msg)))
1195:           (if (string= last-role curr-role)
1196:               ;; Merge with previous
1197:               (progn
1198:                 (let ((merged (greger-parser--merge-message-contents last msg)))
1199:                   (setcar result merged)))
1200:             ;; Add as new message
1201:             (progn
1202:               (push msg result)))))
1203:       (reverse result))))
1204: 
1205: (defun greger-parser--merge-message-contents (msg1 msg2)
1206:   "Merge contents of MSG1 and MSG2."
1207:   (let ((role (alist-get 'role msg1))
1208:         (content1 (alist-get 'content msg1))
1209:         (content2 (alist-get 'content msg2)))
1210:     (let ((merged-content (greger-parser--merge-contents content1 content2)))
1211:       `((role . ,role)
1212:         (content . ,merged-content)))))
1213: 
1214: (defun greger-parser--merge-contents (content1 content2)
1215:   "Merge CONTENT1 and CONTENT2 values."
1216:   (let ((blocks1 (greger-parser--content-to-blocks content1))
1217:         (blocks2 (greger-parser--content-to-blocks content2)))
1218:     (let ((result (append blocks1 blocks2)))
1219:       result)))
1220: 
1221: (defun greger-parser--content-to-blocks (content)
1222:   "Convert CONTENT to content blocks."
1223:   (let ((result (cond
1224:                  ((stringp content)
1225:                   `(((type . "text") (text . ,content))))
1226:                  ((listp content)
1227:                   content)
1228:                  (t
1229:                   `(((type . "text") (text . ,(format "%s" content))))))))
1230:     result))
1231: 
1232: ;; Markdown generation
1233: 
1234: (defun greger-parser--message-to-markdown (message)
1235:   "Convert MESSAGE to markdown."
1236:   (let ((role (alist-get 'role message))
1237:         (content (alist-get 'content message)))
1238:     (cond
1239:      ((string= role "user")
1240:       (greger-parser--user-to-markdown content))
1241:      ((string= role "assistant")
1242:       (greger-parser--assistant-to-markdown content))
1243:      ((string= role "system")
1244:       (greger-parser--system-to-markdown content))
1245:      (t ""))))
1246: 
1247: (defun greger-parser--user-to-markdown (content)
1248:   "Convert user CONTENT to markdown."
1249:   (if (stringp content)
1250:       (concat greger-parser-user-tag "\n\n" content)
1251:     (concat greger-parser-user-tag "\n\n"
1252:             (greger-parser--content-blocks-to-markdown content))))
1253: 
1254: (defun greger-parser--assistant-to-markdown (content)
1255:   "Convert assistant CONTENT to markdown."
1256:   (if (stringp content)
1257:       (concat greger-parser-assistant-tag "\n\n" content)
1258:     (greger-parser--content-blocks-to-markdown-with-citations content)))
1259: 
1260: (defun greger-parser--system-to-markdown (content)
1261:   "Convert system CONTENT to markdown."
1262:   (concat greger-parser-system-tag "\n\n" content))
1263: 
1264: (defun greger-parser--content-blocks-to-markdown (blocks)
1265:   "Convert content BLOCKS to markdown."
1266:   (mapconcat #'greger-parser--block-to-markdown blocks "\n\n"))
1267: 
1268: (defun greger-parser--content-blocks-to-markdown-with-citations (blocks)
1269:   "Convert content BLOCKS to markdown, collecting citations into a separate section."
1270:   (let ((block-markdown "")
1271:         (collected-citations '())
1272:         (first-text-block t)
1273:         (prev-block-type nil))
1274:     ;; Process each block and collect citations
1275:     (dolist (block blocks)
1276:       (let ((block-result (greger-parser--block-to-markdown-with-citations block))
1277:             (current-block-type (alist-get 'type block)))
1278:         (let ((markdown (plist-get block-result :markdown)))
1279:           ;; Add section headers for text blocks that need them
1280:           (when (and (not (string-empty-p markdown))
1281:                      (string= "text" current-block-type)
1282:                      first-text-block)
1283:             (setq first-text-block nil)
1284:             (setq markdown (concat greger-parser-assistant-tag "\n\n" markdown)))
1285:           ;; Determine separator - no separator for consecutive text blocks
1286:           (let ((separator (cond
1287:                            ((string-empty-p block-markdown) "")
1288:                            ((and (string= "text" current-block-type)
1289:                                  (string= "text" prev-block-type)) "")
1290:                            (t "\n\n"))))
1291:             (setq block-markdown (concat block-markdown separator markdown)))
1292:           (setq prev-block-type current-block-type))
1293:         ;; Collect citations if any
1294:         (when (plist-get block-result :citations)
1295:           (setq collected-citations (append collected-citations (plist-get block-result :citations))))))
1296:     ;; Combine block markdown with citations section if any citations were found
1297:     (if collected-citations
1298:         (concat block-markdown "\n\n" (greger-parser--citations-to-markdown collected-citations))
1299:       block-markdown)))
1300: 
1301: (defun greger-parser--citations-to-markdown (citations)
1302:   "Convert CITATIONS list to markdown citations section."
1303:   (when citations
1304:     (concat greger-parser-citations-tag "\n\n"
1305:             (mapconcat #'greger-parser--citation-to-markdown citations "\n\n"))))
1306: 
1307: (defun greger-parser--citation-to-markdown (citation)
1308:   "Convert single CITATION to markdown format."
1309:   (let ((url (alist-get 'url citation))
1310:         (title (alist-get 'title citation))
1311:         (cited-text (alist-get 'cited_text citation))
1312:         (encrypted-index (alist-get 'encrypted_index citation)))
1313:     (concat "### " url "\n\n"
1314:             "Title: " title "\n"
1315:             "Cited text: " cited-text "\n"
1316:             "Encrypted index: " encrypted-index)))
1317: 
1318: (defun greger-parser--block-to-markdown (block)
1319:   "Convert single BLOCK to markdown."
1320:   (let ((result (greger-parser--block-to-markdown-with-citations block)))
1321:     (plist-get result :markdown)))
1322: 
1323: (defun greger-parser--block-to-markdown-with-citations (block)
1324:   "Convert single BLOCK to markdown, extracting citations if present.
1325: Returns a plist with :markdown and optionally :citations."
1326:   (let ((type (alist-get 'type block)))
1327:     (cond
1328:      ((string= type "text")
1329:       (let ((text (alist-get 'text block))
1330:             (citations (alist-get 'citations block)))
1331:         (let ((formatted-text (if citations
1332:                                   (concat "<cite>" text "</cite>")
1333:                                 text)))
1334:           (list :markdown formatted-text
1335:                 :citations citations))))
1336:      ((string= type "thinking")
1337:       (list :markdown (concat greger-parser-thinking-tag "\n\n"
1338:                              (alist-get 'thinking block))))
1339:      ((string= type "tool_use")
1340:       (list :markdown (greger-parser--tool-use-to-markdown block)))
1341:      ((string= type "tool_result")
1342:       (list :markdown (greger-parser--tool-result-to-markdown block)))
1343:      ((string= type "server_tool_use")
1344:       (list :markdown (greger-parser--server-tool-use-to-markdown block)))
1345:      ((string= type "server_tool_result")
1346:       (list :markdown (greger-parser--server-tool-result-to-markdown block)))
1347:      ((string= type "web_search_tool_result")
1348:       (list :markdown (greger-parser--web-search-tool-result-to-markdown block)))
1349:      (t (list :markdown "")))))
1350: 
1351: (defun greger-parser--tool-use-to-markdown (tool-use)
1352:   "Convert TOOL-USE to markdown."
1353:   (let ((name (alist-get 'name tool-use))
1354:         (id (alist-get 'id tool-use))
1355:         (input (alist-get 'input tool-use)))
1356:     (concat greger-parser-tool-use-tag "\n\n"
1357:             "Name: " name "\n"
1358:             "ID: " id "\n\n"
1359:             (greger-parser--tool-params-to-markdown id input))))
1360: 
1361: (defun greger-parser--tool-result-to-markdown (tool-result)
1362:   "Convert TOOL-RESULT to markdown."
1363:   (let ((id (alist-get 'tool_use_id tool-result))
1364:         (content (alist-get 'content tool-result)))
1365:     (concat greger-parser-tool-result-tag "\n\n"
1366:             "ID: " id "\n\n"
1367:             "<tool." id ">\n"
1368:             content "\n"
1369:             "</tool." id ">")))
1370: 
1371: (defun greger-parser--server-tool-use-to-markdown (server-tool-use)
1372:   "Convert SERVER-TOOL-USE to markdown."
1373:   (let ((name (alist-get 'name server-tool-use))
1374:         (id (alist-get 'id server-tool-use))
1375:         (input (alist-get 'input server-tool-use)))
1376:     (concat greger-parser-server-tool-use-tag "\n\n"
1377:             "Name: " name "\n"
1378:             "ID: " id "\n\n"
1379:             (greger-parser--tool-params-to-markdown id input))))
1380: 
1381: (defun greger-parser--server-tool-result-to-markdown (server-tool-result)
1382:   "Convert SERVER-TOOL-RESULT to markdown."
1383:   (let ((id (alist-get 'tool_use_id server-tool-result))
1384:         (content (alist-get 'content server-tool-result)))
1385:     (concat greger-parser-server-tool-result-tag "\n\n"
1386:             "ID: " id "\n\n"
1387:             "<tool." id ">\n"
1388:             (if (stringp content)
1389:                 content
1390:               (greger-parser--value-to-string content)) "\n"
1391:             "</tool." id ">")))
1392: 
1393: (defun greger-parser--web-search-tool-result-to-markdown (web-search-result)
1394:   "Convert WEB-SEARCH-RESULT to markdown."
1395:   (let ((id (alist-get 'tool_use_id web-search-result))
1396:         (content (alist-get 'content web-search-result)))
1397:     (concat greger-parser-server-tool-result-tag "\n\n"
1398:             "ID: " id "\n\n"
1399:             "<tool." id ">\n"
1400:             (if (stringp content)
1401:                 content
1402:               (greger-parser--value-to-string content)) "\n"
1403:             "</tool." id ">")))
1404: 
1405: (defun greger-parser--tool-params-to-markdown (id input)
1406:   "Convert tool parameters with ID and INPUT to markdown."
1407:   (if (null input)
1408:       ""
1409:     (mapconcat (lambda (param)
1410:                  (let ((name (symbol-name (car param)))
1411:                        (value (cdr param)))
1412:                    (concat "### " name "\n\n"
1413:                            "<tool." id ">\n"
1414:                            (greger-parser--value-to-string value) "\n"
1415:                            "</tool." id ">")))
1416:                input "\n\n")))
1417: 
1418: (defun greger-parser--value-to-string (value)
1419:   "Convert VALUE to string representation."
1420:   (let ((json-encoding-pretty-print t))
1421:     (cond
1422:     ((stringp value)
1423:      ;; Try to parse as JSON and pretty print if valid
1424:      (condition-case nil
1425:          (let ((parsed (json-read-from-string value)))
1426:            ;; If parsing succeeded, encode back with pretty print
1427:            (json-encode parsed))
1428:        (error
1429:         ;; If parsing failed, return original string
1430:         value)))
1431:     ((numberp value) (number-to-string value))
1432:     ((eq value t) "true")
1433:     ((null value) "false")
1434:     ((vectorp value) (json-encode value))
1435:     ((listp value) (json-encode value))
1436:     (t (format "%s" value)))))
1437: 
1438: ;; Global debug flag for interactive debugging
1439: (defvar greger-parser--global-debug nil
1440:   "Global debug flag for interactive debugging.")
1441: 
1442: ;; Debug helper functions
1443: (defun greger-parser-enable-debug ()
1444:   "Enable parser debug output."
1445:   (interactive)
1446:   (setq greger-parser--global-debug t)
1447:   (message "Parser debug enabled"))
1448: 
1449: (defun greger-parser-disable-debug ()
1450:   "Disable parser debug output."
1451:   (interactive)
1452:   (setq greger-parser--global-debug nil)
1453:   (message "Parser debug disabled"))
1454: 
1455: (defun greger-parser-parse-dialog-debug (markdown)
1456:   "Parse MARKDOWN into dialog format with debug enabled."
1457:   (greger-parser-parse-dialog markdown (or greger-parser--global-debug t)))
1458: 
1459: (provide 'greger-parser)
1460: 
1461: ;;; greger-parser.el ends here
</tool.toolu_01H3AwPhJDjRiWTGog79nkzD>

## ASSISTANT:

Now let me examine the greger-client.el file to see the current streaming implementation:

## TOOL USE:

Name: read-file
ID: toolu_01BmdwMrRueVUD3fFi2oB3fq

### path

<tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>
greger-client.el
</tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>

### include-line-numbers

<tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>
true
</tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>

## TOOL RESULT:

ID: toolu_01BmdwMrRueVUD3fFi2oB3fq

<tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>
  1: ;;; greger-client.el --- Claude client for greger -*- lexical-binding: t -*-
  2: 
  3: ;; Copyright (C) 2023 Andreas Jansson
  4: 
  5: ;; Author: Andreas Jansson <andreas@jansson.me.uk>
  6: ;; Version: 0.1.0
  7: ;; URL: https://github.com/andreasjansson/greger.el
  8: ;; SPDX-License-Identifier: MIT
  9: 
 10: ;; Permission is hereby granted, free of charge, to any person obtaining a copy
 11: ;; of this software and associated documentation files (the "Software"), to deal
 12: ;; in the Software without restriction, including without limitation the rights
 13: ;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 14: ;; copies of the Software, and to permit persons to whom the Software is
 15: ;; furnished to do so, subject to the following conditions:
 16: 
 17: ;; The above copyright notice and this permission notice shall be included in all
 18: ;; copies or substantial portions of the Software.
 19: 
 20: ;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 21: ;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 22: ;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 23: ;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 24: ;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 25: ;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 26: ;; SOFTWARE.
 27: 
 28: ;;; Commentary:
 29: ;; Simplified Claude client supporting only claude-sonnet-4 and claude-opus-4
 30: 
 31: ;;; Code:
 32: 
 33: (require 'json)
 34: (require 'cl-lib)
 35: 
 36: ;;; Constants and configuration
 37: 
 38: (defconst greger-client-supported-models
 39:   '(claude-sonnet-4-20250514 claude-opus-4-20250514)
 40:   "List of supported Claude models.")
 41: 
 42: (defconst greger-client-api-url "https://api.anthropic.com/v1/messages"
 43:   "Claude API endpoint URL.")
 44: 
 45: ;;; Data structures
 46: 
 47: (cl-defstruct greger-client-state
 48:   accumulated-output
 49:   content-blocks
 50:   process
 51:   output-buffer ;; used for undo handle
 52:   undo-handle
 53:   block-start-callback
 54:   text-delta-callback
 55:   block-stop-callback
 56:   complete-callback
 57:   restore-callback)
 58: 
 59: ;;; Public API
 60: 
 61: (cl-defun greger-client-stream (&key model dialog tools server-tools buffer block-start-callback text-delta-callback block-stop-callback complete-callback)
 62:   (unless (memq model greger-client-supported-models)
 63:     (error "Unsupported model: %s. Supported models: %s"
 64:            model greger-client-supported-models))
 65: 
 66:   (let* ((output-buffer (or buffer (current-buffer)))
 67:          (undo-handle (prepare-change-group output-buffer))
 68:          (request-spec (greger-client--build-request model dialog tools server-tools))
 69:          (restore-callback (lambda (state)
 70:                              (with-current-buffer (greger-client-state-output-buffer state)
 71:                                (undo-amalgamate-change-group (greger-client-state-undo-handle state))
 72:                                (accept-change-group (greger-client-state-undo-handle state)))))
 73: 
 74:          (process (greger-client--start-curl-process request-spec))
 75:          (state (make-greger-client-state
 76:                  :accumulated-output ""
 77:                  ;:complete-response ""
 78:                  :content-blocks '()
 79:                  :process process
 80:                  :block-start-callback block-start-callback
 81:                  :text-delta-callback text-delta-callback
 82:                  :block-stop-callback block-stop-callback
 83:                  :complete-callback complete-callback
 84:                  :restore-callback restore-callback
 85:                  :output-buffer output-buffer
 86:                  :undo-handle undo-handle)))
 87: 
 88:     (activate-change-group undo-handle)
 89: 
 90:     (set-process-filter process
 91:                        (lambda (_proc output)
 92:                          (greger-client--process-output-chunk output state)))
 93: 
 94:     (set-process-sentinel process
 95:                          (lambda (proc _event)
 96:                            (greger-client--handle-completion proc state)))
 97: 
 98:     (set-process-query-on-exit-flag process nil)
 99: 
100:     state))
101: 
102: ;;; Request building
103: 
104: (defun greger-client--build-request (model dialog &optional tools server-tools)
105:   "Build Claude request for MODEL with DIALOG and optional TOOLS and SERVER-TOOLS."
106:   (let* ((api-key (greger-client--get-api-key))
107:          (headers (greger-client--build-headers api-key))
108:          (data (greger-client--build-data model dialog tools server-tools)))
109:     (list :url greger-client-api-url
110:           :method "POST"
111:           :headers headers
112:           :data data)))
113: 
114: (defun greger-client--get-api-key ()
115:   "Get Claude API key from environment."
116:   (let ((api-key (getenv "ANTHROPIC_API_KEY")))
117:     (unless api-key
118:       (error "Please set the ANTHROPIC_API_KEY environment variable"))
119:     api-key))
120: 
121: (defun greger-client--build-headers (api-key)
122:   "Build headers for Claude with API-KEY."
123:   `(("Content-Type" . "application/json")
124:     ("x-api-key" . ,api-key)
125:     ("anthropic-version" . "2023-06-01")
126:     ("anthropic-beta" . "token-efficient-tools-2025-02-19")))
127: 
128: (defun greger-client--build-data (model dialog &optional tools server-tools)
129:   "Build request data for Claude MODEL with DIALOG and optional TOOLS and SERVER-TOOLS."
130:   (let ((system-message nil)
131:         (user-messages ())
132:         (request-data nil))
133: 
134:     ;; Separate system messages from user/assistant messages
135:     (dolist (message dialog)
136:       (let ((role (alist-get 'role message))
137:             (content (alist-get 'content message)))
138:         (if (string= role "system")
139:             (unless system-message
140:               (setq system-message content))
141:           (push `((role . ,role)
142:                   (content . ,content))
143:                 user-messages))))
144: 
145:     ;; Reverse to get correct order
146:     (setq user-messages (nreverse user-messages))
147: 
148:     ;; Find the last message with dict content and add ephemeral cache control
149:     (let ((last-dict-message nil))
150:       (dolist (message user-messages)
151:         (let ((content (alist-get 'content message)))
152:           (when (and (listp content) (not (stringp content)))
153:             (setq last-dict-message message))))
154: 
155:       (when last-dict-message
156:         (let ((content-list (alist-get 'content last-dict-message)))
157:           ;; Modify the first content item in place
158:           (when (and content-list (listp content-list))
159:             (let ((first-content-item (car content-list)))
160:               (when (and first-content-item (listp first-content-item))
161:                 ;; Modify the car of the content-list directly
162:                 (setcar content-list
163:                         (cons '(cache_control . ((type . "ephemeral")))
164:                               first-content-item))))))))
165: 
166:     ;; Build base request
167:     (setq request-data `(("model" . ,(symbol-name model))
168:                         ("messages" . ,user-messages)
169:                         ("max_tokens" . 64000)
170:                         ("stream" . t)))
171: 
172:     ;; Add system message if present
173:     (when system-message
174:       (push `("system" . ,system-message) request-data))
175: 
176:     ;; Add tools if present
177:     (when (or tools server-tools)
178:       ;; TODO: why are we parsing server tools here?
179:       (let* ((parsed-server-tools (when server-tools
180:                                     (mapcar (lambda (json-string)
181:                                               (json-parse-string json-string :object-type 'alist))
182:                                             server-tools)))
183:              (all-tools (append (or tools '()) (or parsed-server-tools '()))))
184:         (push `("tools" . ,all-tools) request-data)
185:         (push `("tool_choice" . (("type" . "auto"))) request-data)))
186: 
187:     (json-encode request-data)))
188: 
189: ;;; Stream processing
190: 
191: (defun greger-client--check-for-error (output)
192:   "Check OUTPUT for error responses and raise an error if found.
193: Returns nil if no error found or if OUTPUT is not valid JSON."
194:   (condition-case nil
195:       (let ((data (json-read-from-string output)))
196:         (when (and (listp data)
197:                    (string= (alist-get 'type data) "error"))
198:           (let* ((error-info (alist-get 'error data))
199:                  (error-message (alist-get 'message error-info))
200:                  (error-type (alist-get 'type error-info)))
201:             (error "API Error (%s): %s" error-type error-message))))
202:     (json-error nil)
203:     (json-readtable-error nil)))
204: 
205: (defun greger-client--process-output-chunk (output state)
206:   "Process a chunk of OUTPUT using STATE."
207: 
208:   ;; TODO: remove debug
209:   ;(message "output: %s" output)
210: 
211:   ;; Check for error responses and raise an error if found
212:   (greger-client--check-for-error output)
213: 
214:   ;; Always accumulate for complete response
215:   ;(setf (greger-client-state-complete-response state)
216:   ;      (concat (greger-client-state-complete-response state) output))
217: 
218:   ;; Update working buffer for chunk processing
219:   (setf (greger-client-state-accumulated-output state)
220:         (concat (greger-client-state-accumulated-output state) output))
221: 
222:   (greger-client--process-events state))
223: 
224: (defun greger-client--process-events (state)
225:   "Process Claude streaming events from accumulated output in STATE."
226:   (let ((accumulated (greger-client-state-accumulated-output state)))
227: 
228:     ;; Process complete lines (events)
229:     (while (string-match "\n" accumulated)
230:       (let* ((line-end (match-end 0))
231:              (line (substring accumulated 0 (1- line-end))))
232: 
233:         ;; Process the line if it's a data event
234:         (when (string-prefix-p "data: " line)
235:           (let ((data-json (substring line 6)))
236:             (unless (string= data-json "[DONE]")
237:               (greger-client--handle-event data-json state))))
238: 
239:         ;; Remove processed line
240:         (setq accumulated (substring accumulated line-end))))
241: 
242:     ;; Store remaining incomplete data
243:     (setf (greger-client-state-accumulated-output state) accumulated)))
244: 
245: (defun greger-client--handle-event (data-json state)
246:   "Handle a Claude streaming event with DATA-JSON using STATE."
247:   (let* ((data (json-read-from-string data-json))
248:          (type (alist-get 'type data)))
249:     (cond
250:      ;; Content block start - create new content block
251:      ((string= type "content_block_start")
252:       (greger-client--handle-content-block-start data state))
253: 
254:      ;; Content block delta - update existing content block
255:      ((string= type "content_block_delta")
256:       (greger-client--handle-content-block-delta data state))
257: 
258:      ;; Content block stop - finalize tool input if needed
259:      ((string= type "content_block_stop")
260:       (greger-client--handle-content-block-stop data state)))))
261: 
262: (defun greger-client--handle-content-block-start (data state)
263:   (let* ((index (alist-get 'index data))
264:          (content-block (copy-alist (alist-get 'content_block data)))
265:          (blocks (greger-client-state-content-blocks state))
266:          (type (alist-get 'type content-block)))
267: 
268:     ;; Initialize content for accumulation.
269:     ;; For tool_use and server_tool_use we make the input object a
270:     ;; string while we accumulate the output, and turn it back into
271:     ;; an object again in greger-client--handle-content-stop
272:     (cond
273:      ((string= type "tool_use")
274:       (setf (alist-get 'input content-block) ""))
275: 
276:      ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
277:      ((string= type "server_tool_use")
278:       (setf (alist-get 'input content-block) ""))
279: 
280:      ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
281:      ((string= type "text")
282:       (setf (alist-get 'text content-block) ""))
283: 
284:      ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Sweden Population (2025) - Worldometer","url":"https://www.worldometers.info/world-population/sweden-population/","encrypted_content":"Ev0P...YMYAw==","page_age":null}, [...] ]}}
285:      ((string= type "web_search_tool_result")
286:       ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
287:       nil))
288: 
289:     (funcall (greger-client-state-block-start-callback state) type)
290: 
291:     ;; Add block at the right index
292:     (greger-client--ensure-block-at-index blocks index content-block state)))
293: 
294: (defun greger-client--handle-content-block-delta (data state)
295:   (let* ((index (alist-get 'index data))
296:          (delta (alist-get 'delta data))
297:          (delta-type (alist-get 'type delta))
298:          (blocks (greger-client-state-content-blocks state))
299:          (block (nth index blocks)))
300: 
301:     ;; TODO: do we need to handle content block stop out-of-order,
302:     ;; before content-block start has created the block in the state's content-blocks?
303: 
304:     (cond
305: 
306:      ;; assistant text and thinking
307:      ;; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"I'll search for the"}}
308:      ((string= delta-type "text_delta")
309:       (let ((text (alist-get 'text delta)))
310:         (setf (alist-get 'text block)
311:               (concat (alist-get 'text block) text))
312:         ;; Call text callback for live display
313:         (funcall (greger-client-state-text-delta-callback state) text)))
314: 
315:      ;; tool_use and server_tool_use
316:      ;; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":""}}
317:      ((string= delta-type "input_json_delta")
318:       (let ((partial-json (alist-get 'partial_json delta)))
319:         (setf (alist-get 'input block)
320:               (concat (alist-get 'input block) partial-json)))))))
321: 
322: (defun greger-client--handle-content-block-stop (data state)
323:   (let* ((index (alist-get 'index data))
324:          (blocks (greger-client-state-content-blocks state))
325:          (block (nth index blocks))
326:          (type (alist-get 'type block)))
327: 
328:     ;; TODO: do we need to handle content block stop out-of-order,
329:     ;; before content-block start has created the block in the state's content-blocks?
330: 
331:     (when (or (string= type "tool_use") (string= type "server_tool_use"))
332: 
333:       ;; Turn accumulated JSON string back into an object
334:       (let ((input-str (alist-get 'input block)))
335:         (if (string-empty-p input-str)
336:             (setf (alist-get 'input block) '())
337:           (setf (alist-get 'input block) (json-read-from-string input-str)))))
338: 
339:     (funcall (greger-client-state-block-stop-callback state) type block)))
340: 
341: (defun greger-client--ensure-block-at-index (_blocks index new-block state)
342:   "Ensure BLOCKS list has NEW-BLOCK at INDEX, extending if necessary.
343: STATE is used to update the parsed content blocks."
344:   (let ((current-blocks (greger-client-state-content-blocks state)))
345:     ;; Extend list if needed
346:     (while (<= (length current-blocks) index)
347:       (setq current-blocks (append current-blocks (list nil))))
348: 
349:     ;; Set the block at index
350:     (setf (nth index current-blocks) new-block)
351:     (setf (greger-client-state-content-blocks state) current-blocks)))
352: 
353: (defun greger-client--handle-completion (proc state)
354:   "Handle process completion for PROC using STATE."
355:   (when (memq (process-status proc) '(exit signal))
356:     (funcall (greger-client-state-restore-callback state) state)
357: 
358:     (if (= (process-exit-status proc) 0)
359:         (when (greger-client-state-complete-callback state)
360:           (let ((content-blocks (greger-client-state-content-blocks state)))
361:             (funcall (greger-client-state-complete-callback state) content-blocks))))))
362: 
363: (defun greger-client--cancel-request (state)
364:   "Cancel streaming request using STATE."
365:   (let ((process (greger-client-state-process state)))
366:     (when (process-live-p process)
367:       (message "Interrupting generation")
368:       (interrupt-process process)
369:       (sit-for 0.1)
370:       (delete-process process))
371:     (funcall (greger-client-state-restore-callback state) state)))
372: 
373: ;;; Utility functions
374: 
375: (defun greger-client--start-curl-process (request-spec)
376:   "Start curl process with REQUEST-SPEC."
377:   (start-process-shell-command
378:    "greger-curl" nil
379:    (greger-client--build-curl-command request-spec)))
380: 
381: (defun greger-client--build-curl-command (request-spec)
382:   "Build curl command from REQUEST-SPEC."
383:   (let ((url (plist-get request-spec :url))
384:         (method (plist-get request-spec :method))
385:         (headers (plist-get request-spec :headers))
386:         (data (plist-get request-spec :data)))
387:     (format "curl -s -X %s %s %s %s"
388:             method
389:             (mapconcat (lambda (header)
390:                          (format "-H \"%s: %s\"" (car header) (cdr header)))
391:                        headers " ")
392:             (if data
393:                 (format "--data-raw %s" (shell-quote-argument data))
394:               "")
395:             url)))
396: 
397: (provide 'greger-client)
398: 
399: ;;; greger-client.el ends here
</tool.toolu_01BmdwMrRueVUD3fFi2oB3fq>

## ASSISTANT:

Now let me examine the greger.el file to see how the streaming is currently handled:

## TOOL USE:

Name: read-file
ID: toolu_011kDH9n9ZsTt4TjoHu5wiRK

### path

<tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>
greger.el
</tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>

### include-line-numbers

<tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>
true
</tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>

### start-line

<tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>
1
</tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>

### end-line

<tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>
400
</tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>

## TOOL RESULT:

ID: toolu_011kDH9n9ZsTt4TjoHu5wiRK

<tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>
  1: ;;; greger.el --- Chat with language models -*- lexical-binding: t -*-
  2: 
  3: ;; Copyright (C) 2023 Andreas Jansson
  4: 
  5: ;; Author: Andreas Jansson <andreas@jansson.me.uk>
  6: ;; Version: 0.1.0
  7: ;; URL: https://github.com/andreasjansson/greger.el
  8: ;; Package-Requires: ((emacs "28.1") (markdown-mode "2.3"))
  9: ;; Keywords: ai, chat, language-models, tools
 10: ;; SPDX-License-Identifier: MIT
 11: 
 12: ;; Permission is hereby granted, free of charge, to any person obtaining a copy
 13: ;; of this software and associated documentation files (the "Software"), to deal
 14: ;; in the Software without restriction, including without limitation the rights
 15: ;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 16: ;; copies of the Software, and to permit persons to whom the Software is
 17: ;; furnished to do so, subject to the following conditions:
 18: 
 19: ;; The above copyright notice and this permission notice shall be included in all
 20: ;; copies or substantial portions of the Software.
 21: 
 22: ;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 23: ;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 24: ;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 25: ;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 26: ;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 27: ;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 28: ;; SOFTWARE.
 29: 
 30: ;;; Commentary:
 31: ;; This package provides an interface for interacting with AI language models
 32: 
 33: ;;; Code:
 34: 
 35: (require 'cl-lib)
 36: (require 'json)
 37: (require 'markdown-mode)
 38: 
 39: (require 'greger-client)
 40: (require 'greger-parser)
 41: (require 'greger-tools)
 42: (require 'greger-stdlib)
 43: 
 44: 
 45: 
 46: (defconst greger-available-models
 47:   '(claude-sonnet-4-20250514
 48:     claude-opus-4-20250514)
 49:   "List of available models.")
 50: 
 51: (defcustom greger-model 'claude-sonnet-4-20250514
 52:   "The currently used model."
 53:   :type `(choice ,@(mapcar (lambda (model) `(const ,model)) greger-available-models))
 54:   :group 'greger)
 55: 
 56: (defcustom greger-default-system-prompt "You are a helpful assistant."
 57:   "Default system prompt used for AI interactions."
 58:   :type 'string
 59:   :group 'greger)
 60: 
 61: (defcustom greger-temperature 0.8
 62:   "Sampling temperature between 0 and 1."
 63:   :type 'float
 64:   :group 'greger)
 65: 
 66: ;; Tool configuration and agent functionality
 67: 
 68: (defun greger--default-tools ()
 69:   "Return default tools list, including LSP tools if available."
 70:   (let ((base-tools '("read-file" "list-directory" "str-replace" "insert" "write-new-file" "replace-file" "make-directory" "rename-file" "ripgrep" "git-log" "git-show-commit" "shell-command" "read-webpage" "delete-files"))
 71:         (lsp-tools '("lsp-rename" "lsp-find-definition" "lsp-find-references" "lsp-format" "lsp-document-symbols")))
 72:     (if (and (boundp 'greger--lsp-available) greger--lsp-available)
 73:         (append base-tools lsp-tools)
 74:       base-tools)))
 75: 
 76: (defcustom greger-tools (greger--default-tools)
 77:   "List of tools available to the agent."
 78:   :type '(repeat symbol)
 79:   :group 'greger)
 80: 
 81: (defcustom greger-server-tools '("web_search")
 82:   "List of server tools available to the agent (e.g., web_search)."
 83:   :type '(repeat symbol)
 84:   :group 'greger)
 85: 
 86: (defcustom greger-max-iterations 100
 87:   "Maximum number of agent iterations before stopping."
 88:   :type 'integer
 89:   :group 'greger)
 90: 
 91: (defcustom greger-debug nil
 92:   "Whether to show debug information."
 93:   :type 'boolean
 94:   :group 'greger)
 95: 
 96: ;;; Agent state structure
 97: 
 98: (cl-defstruct greger-state
 99:   current-iteration
100:   chat-buffer
101:   directory
102:   metadata
103:   client-state
104:   executing-tools)
105: 
106: (defvar greger-user-tag "## USER:")
107: (defvar greger-assistant-tag "## ASSISTANT:")
108: (defvar greger-system-tag "## SYSTEM:")
109: 
110: ;; Tool section collapsing variables
111: (defvar greger-tool-section-max-lines 4
112:   "Maximum number of lines to show in collapsed tool sections.")
113: 
114: (defvar-local greger-tool-overlays nil
115:   "List of overlays used for collapsible tool sections.")
116: 
117: (defvar-local greger--current-state nil
118:   "Buffer-local variable to track the current state.")
119: 
120: (defvar-local greger--buffer-read-only-by-greger nil
121:   "Buffer-local variable to track if buffer is read-only due to greger activity.")
122: 
123: (defvar-local greger--unfolded-tool-ids nil
124:   "List of tool IDs that have been manually unfolded.
125: These tool IDs should not be auto-folded again.")
126: 
127: ;; Face definitions for tool tags
128: (defface greger-tool-tag-face
129:   '((t :height 0.6 :foreground "gray70"))
130:   "Face for tool opening and closing tags."
131:   :group 'greger)
132: 
133: (defface greger-tool-content-face
134:   '((t :inherit default))
135:   "Face for tool content."
136:   :group 'greger)
137: 
138: (defface greger-tool-param-heading-face
139:   '((t :foreground "#6699CC" :weight bold :height 1.0))
140:   "Face for ### tool parameter headings in greger mode."
141:   :group 'greger)
142: 
143: (defface greger-user-heading-face
144:   '((t :foreground "#66DD66" :weight bold :height 1.2))
145:   "Face for ## USER: headings in greger mode."
146:   :group 'greger)
147: 
148: (defface greger-tool-result-heading-face
149:   '((t :foreground "#66AA88" :weight bold :height 1.2))
150:   "Face for ## TOOL RESULT: headings in greger mode."
151:   :group 'greger)
152: 
153: (defface greger-assistant-heading-face
154:   '((t :foreground "#AA9922" :weight bold :height 1.2))
155:   "Face for ## ASSISTANT: headings in greger mode."
156:   :group 'greger)
157: 
158: (defface greger-thinking-heading-face
159:   '((t :foreground "#9966CC" :weight bold :height 1.2))
160:   "Face for ## THINKING: headings in greger mode."
161:   :group 'greger)
162: 
163: (defface greger-tool-use-heading-face
164:   '((t :foreground "#8866BB" :weight bold :height 1.2))
165:   "Face for ## TOOL USE: headings in greger mode."
166:   :group 'greger)
167: 
168: (defface greger-system-heading-face
169:   '((t :foreground "#CC6666" :weight bold :height 1.2))
170:   "Face for ## SYSTEM: headings in greger mode."
171:   :group 'greger)
172: 
173: (defvar greger-mode-map
174:   (let ((map (make-sparse-keymap)))
175:     (define-key map (kbd "M-<return>") #'greger-buffer)
176:     (define-key map (kbd "C-M-<return>") #'greger-buffer-no-tools)
177:     (define-key map (kbd "C-g") #'greger-interrupt)
178:     (define-key map (kbd "C-; a") #'greger-insert-assistant-tag)
179:     (define-key map (kbd "C-; u") #'greger-insert-user-tag)
180:     (define-key map (kbd "C-; s") #'greger-insert-system-tag)
181:     (define-key map (kbd "C-; i") #'greger-insert-include)
182:     (define-key map (kbd "C-; I") #'greger-insert-include-code)
183:     (define-key map (kbd "C-; f") #'greger-insert-include-file)
184:     (define-key map (kbd "C-; b") #'greger-insert-include-buffer-code)
185:     (define-key map (kbd "C-; m") #'greger-set-model)
186:     (define-key map (kbd "C-; c") #'greger-copy-code)
187:     (define-key map (kbd "C-; d") #'greger-debug-request)
188:     (define-key map (kbd "TAB") #'greger-toggle-tool-section)
189:     (define-key map (kbd "<tab>") #'greger-toggle-tool-section)
190:     map)
191:   "Keymap for `greger-mode'.")
192: 
193: (define-derived-mode greger-mode gfm-mode "Greger"
194:   "Major mode for interacting with AI."
195:   (use-local-map greger-mode-map)
196:   (setq-local markdown-fontify-code-blocks-natively t)
197:   (setq-local mode-line-misc-info '(:eval (greger--mode-line-info)))
198:   ;; Set up invisible text for tool sections
199:   (add-to-invisibility-spec 'greger-tool-section)
200:   ;; Set up tool section highlighting and collapsing
201:   (greger--setup-tool-sections)
202:   ;; Set up custom heading font-lock
203:   (greger--setup-heading-font-lock)
204:   ;; Add hook to update tool sections when buffer changes
205:   (add-hook 'after-change-functions #'greger--after-change-function nil t)
206:   ;; Add font-lock hook for immediate tool tag styling
207:   (add-hook 'font-lock-extend-region-functions #'greger--extend-font-lock-region nil t))
208: 
209: ;;;###autoload
210: (defun greger ()
211:   "Create a new buffer and switch to `greger-mode`."
212:   (interactive)
213:   (let ((buffer (generate-new-buffer "*greger*")))
214:     (switch-to-buffer buffer)
215:     (greger-mode)
216:     (insert greger-system-tag
217:             "\n\n" greger-default-system-prompt "\n\n"
218:             greger-user-tag
219:             "\n\n")
220:     (message "Using model %s" greger-model)))
221: 
222: (defun greger-insert-assistant-tag ()
223:   "Insert the assistant tag into the buffer."
224:   (interactive)
225:   (insert greger-assistant-tag "\n\n"))
226: 
227: (defun greger-insert-user-tag ()
228:   "Insert the user tag into the buffer."
229:   (interactive)
230:   (insert greger-user-tag "\n\n"))
231: 
232: (defun greger-insert-system-tag ()
233:   "Insert the system tag into the buffer."
234:   (interactive)
235:   (insert greger-system-tag "\n\n"))
236: 
237: (defun greger-interrupt ()
238:   "Interrupt ongoing generation if active, otherwise call `keyboard-quit'."
239:   (interactive)
240: 
241:   (let* ((buffer (current-buffer))
242:          (state (buffer-local-value 'greger--current-state buffer)))
243:     (cond
244:      ;; If there's an active client state, cancel the streaming request
245:      ((and state (greger-state-client-state state))
246:       (greger-client--cancel-request (greger-state-client-state state))
247:       (setf (greger-state-client-state state) nil)
248:       (greger--update-buffer-state)
249:       'generating)
250:      ;; If there are executing tools, cancel them
251:      ((and state
252:            (greger-state-executing-tools state)
253:            (> (hash-table-count (greger-state-executing-tools state)) 0))
254:       (let ((executing-tools (greger-state-executing-tools state)))
255:         (maphash (lambda (_tool-id greger-tool)
256:                    (let ((cancel-fn (greger-tool-cancel-fn greger-tool)))
257:                      (when (functionp cancel-fn)
258:                        (funcall cancel-fn))))
259:                  executing-tools)
260:         (greger--update-buffer-state))
261:       'executing)
262:      ;; Default case: call keyboard-quit
263:      (t
264:       (keyboard-quit)
265:       'idle))))
266: 
267: (defun greger-buffer-no-tools ()
268:   "Send the buffer content to AI as a dialog without tool use."
269:   (interactive)
270:   (let ((greger-tools '()))
271:     (greger-buffer)))
272: 
273: (defun greger-insert-include ()
274:   "Prompt the user to select a file and insert an <include> at point."
275:   (interactive)
276:   (let ((file (read-string "Filename or URL: ")))
277:     (insert (format "<include>%s</include>\n\n" file))))
278: 
279: (defun greger-insert-include-file ()
280:   "Prompt the user to select a file and insert an <include> at point."
281:   (interactive)
282:   (let ((file (expand-file-name (read-file-name "Select file: " nil nil t))))
283:     (if (file-exists-p file)
284:         (insert (format "<include>%s</include>\n\n" file))
285:       (message "File does not exist!"))))
286: 
287: (defun greger-insert-include-code ()
288:   "Prompt the user to select a file and insert an <include> at point."
289:   (interactive)
290:   (let ((file (read-string "Filename or URL: ")))
291:     (insert (format "<include code>%s</include>\n\n" file))))
292: 
293: (defun greger-insert-include-buffer-code ()
294:   "Prompt the user to select a buffer and insert an <include code> at point."
295:   (interactive)
296:   (let ((buffer-name (read-buffer "Select buffer: " nil t)))
297:     (when buffer-name
298:       (let ((buffer (get-buffer buffer-name)))
299:         (when buffer
300:           (let ((path (buffer-file-name buffer)))
301:             (insert (format "<include code>%s</include>\n\n" path))))))))
302: 
303: (defun greger-copy-code ()
304:   "Copy the current code block under point."
305:   (interactive)
306:   (let ((code-block (greger--get-current-code-block)))
307:     (if code-block
308:         (progn
309:           (kill-new code-block)
310:           (message "Copied code: %s" (greger--truncate-with-ellipsis code-block 40)))
311:       (error "Point is not inside a code block"))))
312: 
313: (defun greger-set-model ()
314:   "Set the current model."
315:   (interactive)
316:   (let ((model (completing-read "Choose model: " greger-available-models nil t)))
317:     (customize-set-variable 'greger-model (intern model))
318:     (message "Model set to %s" model)))
319: 
320: (defun greger-debug-request ()
321:   "Debug the request data by parsing the buffer and saving the request data output."
322:   (interactive)
323:   (let* ((filename (read-string "Save to filename (default: request.json): " nil nil "request.json"))
324:          (buffer-content (buffer-substring-no-properties (point-min) (point-max)))
325:          (parse-result (greger-parser-parse-dialog buffer-content))
326:          (dialog (plist-get parse-result :messages))
327:          (tools (when greger-tools
328:                   (greger-tools-get-schemas greger-tools)))
329:          (model greger-model)
330:          (request-data nil))
331: 
332:     (unless dialog
333:       (error "Failed to parse dialog. Check your buffer format"))
334: 
335:     ;; Get server tools
336:     (let ((server-tools (when greger-server-tools
337:                           (greger-server-tools-get-schemas greger-server-tools))))
338:       ;; Get the JSON request data using the new client
339:       (setq request-data (greger-client--build-data model dialog tools server-tools)))
340: 
341:     ;; Parse the JSON and re-encode with proper formatting
342:     (condition-case err
343:         (let* ((parsed-json (json-read-from-string request-data)))
344:           ;; Write to file with proper indentation
345:           (with-temp-file filename
346:             (let ((json-encoding-pretty-print t))
347:               (insert (json-encode parsed-json))))
348:           (message "Request data saved to %s" filename))
349:       (error
350:        ;; Fallback: just save the raw JSON string if parsing fails
351:        (with-temp-file filename
352:          (insert request-data))
353:        (message "Request data saved to %s (raw format due to parsing error: %s)"
354:                 filename (error-message-string err))))))
355: 
356: ;; Main buffer function with agent functionality
357: 
358: (defun greger-buffer ()
359:   "Send buffer content to AI as an agent dialog with tool support."
360:   (interactive)
361:   (let* ((buffer-content (buffer-substring-no-properties (point-min) (point-max)))
362:          (parse-result (greger-parser-parse-dialog buffer-content))
363:          (dialog (plist-get parse-result :messages))
364:          (metadata (plist-get parse-result :metadata)))
365:     (unless dialog
366:       (error "Failed to parse dialog. Did you forget to close a html tag?"))
367: 
368:     (goto-char (point-max))
369: 
370:     (let ((state (make-greger-state
371:                         :current-iteration 0
372:                         :chat-buffer (current-buffer)
373:                         :directory default-directory
374:                         :metadata metadata)))
375: 
376:       (greger--debug "--- DIALOG --- %s" dialog)
377:       (greger--debug "=== STARTING AGENT SESSION ===")
378: 
379:       (greger--run-agent-loop state))))
380: 
381: (defun greger--debug (format-string &rest args)
382:   "Debug logging function.
383: FORMAT-STRING is the format string.
384: ARGS are arguments to format."
385:   (when greger-debug
386:     (message "[GREGER DEBUG] %s" (apply #'format format-string args))))
387: 
388: (defun greger--get-current-state ()
389:   "Get the current greger state: \='idle, \='generating, or \='executing."
390:   (let ((state (buffer-local-value 'greger--current-state (current-buffer))))
391:     (cond
392:      ;; Check if we're generating (client-state is active)
393:      ((and state (greger-state-client-state state))
394:       'generating)
395:      ;; Check if we're executing tools
396:      ((and state
397:            (greger-state-executing-tools state)
398:            (> (hash-table-count (greger-state-executing-tools state)) 0))
399:       'executing)
400:      ;; Otherwise we're idle
</tool.toolu_011kDH9n9ZsTt4TjoHu5wiRK>

## ASSISTANT:

Let me continue reading the greger.el file to see more of the streaming implementation:

## TOOL USE:

Name: read-file
ID: toolu_017a4MsmvYxP9YFdHyLL37J6

### path

<tool.toolu_017a4MsmvYxP9YFdHyLL37J6>
greger.el
</tool.toolu_017a4MsmvYxP9YFdHyLL37J6>

### include-line-numbers

<tool.toolu_017a4MsmvYxP9YFdHyLL37J6>
true
</tool.toolu_017a4MsmvYxP9YFdHyLL37J6>

### start-line

<tool.toolu_017a4MsmvYxP9YFdHyLL37J6>
400
</tool.toolu_017a4MsmvYxP9YFdHyLL37J6>

### end-line

<tool.toolu_017a4MsmvYxP9YFdHyLL37J6>
800
</tool.toolu_017a4MsmvYxP9YFdHyLL37J6>

## TOOL RESULT:

ID: toolu_017a4MsmvYxP9YFdHyLL37J6

<tool.toolu_017a4MsmvYxP9YFdHyLL37J6>
400:      ;; Otherwise we're idle
401:      (t 'idle))))
402: 
403: (defun greger--mode-line-info ()
404:   "Generate mode line information showing model and current state."
405:   (let ((state (greger--get-current-state))
406:         (model-name (symbol-name greger-model)))
407:     (concat model-name
408:             (pcase state
409:               ('generating " [Generating]")
410:               ('executing " [Executing]")
411:               ('idle "")))))
412: 
413: (defun greger--set-buffer-read-only (read-only)
414:   "Set buffer read-only state for greger operations.
415: READ-ONLY is t to make read-only, nil to make writable."
416:   (if read-only
417:       (unless greger--buffer-read-only-by-greger
418:         (setq greger--buffer-read-only-by-greger t)
419:         (setq buffer-read-only t))
420:     (when greger--buffer-read-only-by-greger
421:       (setq greger--buffer-read-only-by-greger nil)
422:       (setq buffer-read-only nil))))
423: 
424: (defun greger--update-buffer-state ()
425:   "Update buffer read-only state based on current greger state."
426:   (let ((state (greger--get-current-state)))
427:     (greger--set-buffer-read-only (not (eq state 'idle)))
428:     ;; Force mode line update
429:     (force-mode-line-update)))
430: 
431: (defun greger--run-agent-loop (state)
432:   "Run the main agent loop with AGENT-STATE."
433:   (let* ((tools (greger-tools-get-schemas greger-tools))
434:          (server-tools (when greger-server-tools
435:                          (greger-server-tools-get-schemas greger-server-tools)))
436:          (chat-buffer (greger-state-chat-buffer state))
437:          (buffer-content (with-current-buffer chat-buffer
438:                            (buffer-substring-no-properties (point-min) (point-max))))
439:          (parse-result (greger-parser-parse-dialog buffer-content))
440:          (current-dialog (plist-get parse-result :messages))
441:          (current-iteration (greger-state-current-iteration state)))
442: 
443:     (greger--debug "=== ITERATION %d ===" current-iteration)
444:     (greger--debug "Dialog length: %d messages" (length current-dialog))
445: 
446:     ;; Check max iterations
447:     (when (>= current-iteration greger-max-iterations)
448:       (error "Maximum iterations (%d) reached, stopping agent execution" greger-max-iterations))
449: 
450:     ;; Get Claude's response
451:     (greger--debug "CALLING greger-client-stream...")
452:     (let ((client-state (greger-client-stream
453:                          :model greger-model
454:                          :dialog current-dialog
455:                          :tools tools
456:                          :server-tools server-tools
457:                          :buffer chat-buffer
458:                          :block-start-callback (lambda (type) (greger--append-streaming-content-header state type))
459:                          :text-delta-callback (lambda (text) (greger--append-text state text))
460:                          :block-stop-callback (lambda (type content-block) (greger--append-nonstreaming-content-block state type content-block))
461:                          :complete-callback (lambda (content-blocks) (greger--handle-stream-completion state content-blocks)))))
462:       ;; Store the client state for potential cancellation
463:       (setf (greger-state-client-state state) client-state)
464:       ;; Set buffer-local variable for greger-interrupt to access
465:       (with-current-buffer chat-buffer
466:         (setq greger--current-state state) ;; TODO: why do we set that _here_? Or should it be greger--current-client-state instead?
467:         (greger--update-buffer-state)))))
468: 
469: (defun greger--append-streaming-content-header (state type)
470:   (cond
471:    ((string= type "text")
472:     (greger--append-text state (concat "\n\n" greger-parser-assistant-tag "\n\n")))
473:    ((string= type "thinking")
474:     (greger--append-text state (concat "\n\n" greger-parser-thinking-tag "\n\n")))
475:    (t nil)))
476: 
477: (defun greger--handle-stream-completion (state content-blocks)
478:   (let ((tool-calls (greger--extract-tool-calls content-blocks)))
479:     ;; TODO: remove debug
480:     (if tool-calls
481:         (progn
482:           (greger--debug "TOOL USE DETECTED! Found %d tool calls" (length tool-calls))
483:           (setf (greger-state-current-iteration state)
484:                 (1+ (greger-state-current-iteration state)))
485:           ;; TODO: execute tool calls in greger--append-content-block instead
486:           (greger--execute-tools tool-calls state))
487:       (progn
488:         (greger--debug "NO TOOL USE - CONVERSATION COMPLETE")
489:         (greger--finish-response state))))
490: 
491:   (with-current-buffer (greger-state-chat-buffer state)
492:     (greger--update-buffer-state)))
493: 
494: (defun greger--append-nonstreaming-content-block (state type content-block)
495:   (greger--debug "CONTENT BLOCK: %s" content-block)
496: 
497:   (unless (or (string= type "text") (string= type "thinking"))
498: 
499:    (let ((markdown (greger-parser--block-to-markdown content-block)))
500:      (greger--append-text state (concat "\n\n" markdown)))
501: 
502:    (when (string= type "tool_use")
503:      (let ((tool-id (alist-get 'id content-block)))
504:        (greger--append-text state (concat "\n\n" (greger--tool-placeholder tool-id)))))
505: 
506:    ;; Update buffer state after client completes
507:    (with-current-buffer (greger-state-chat-buffer state)
508:      (greger--update-buffer-state))))
509: 
510: (defun greger--extract-tool-calls (content-blocks)
511:   "Extract tool calls from CONTENT-BLOCKS."
512:   (let ((tool-calls '()))
513:     (dolist (block content-blocks)
514:       (when (string= (alist-get 'type block) "tool_use")
515:         (greger--debug "EXTRACTING TOOL CALL: %s with input: %s"
516:                       (alist-get 'name block)
517:                       (json-encode (alist-get 'input block)))
518:         (push block tool-calls)))
519:     (reverse tool-calls)))
520: 
521: (defun greger--tool-placeholder (tool-id)
522:   "Generate placeholder string for TOOL-ID."
523:   (format "<!-- TOOL_RESULT_PLACEHOLDER_%s -->" tool-id))
524: 
525: (defun greger--execute-tools (tool-calls state)
526:   "Execute TOOL-CALLS using AGENT-STATE in parallel with callbacks."
527:   (let* ((total-tools (length tool-calls))
528:          (completed-tools 0)
529:          (executing-tools-map (make-hash-table :test 'equal)))
530: 
531:     ;; Initialize executing-tools in state if not already set
532:     (unless (greger-state-executing-tools state)
533:       (setf (greger-state-executing-tools state) executing-tools-map))
534: 
535:     ;; Update buffer state to show we're executing tools
536:     (with-current-buffer (greger-state-chat-buffer state)
537:       (greger--update-buffer-state))
538: 
539:     ;; First, display the tool calls and reserve space for each tool's output
540:     (with-current-buffer (greger-state-chat-buffer state)
541:       (let ((inhibit-read-only t))
542:         (goto-char (point-max))
543: 
544:         ;; Display each tool call followed by its placeholder
545:         ;; (dolist (tool-call tool-calls)
546:         ;;   (let ((tool-id (alist-get 'id tool-call))
547:         ;;         (tool-block-markdown (greger-parser--content-blocks-to-markdown (list tool-call))))
548:         ;;     (unless (string-empty-p tool-block-markdown)
549:         ;;       (insert "\n\n" tool-block-markdown))
550:         ;;     (insert "\n\n" (greger--tool-placeholder tool-id))))
551:         ))
552: 
553:     ;; Execute all tools in parallel
554:     (dolist (tool-call tool-calls)
555:       (let* ((tool-name (alist-get 'name tool-call))
556:              (tool-input (alist-get 'input tool-call))
557:              (tool-id (alist-get 'id tool-call))
558:              (default-directory (greger-state-directory state))
559: 
560:              ;; TODO: This is ugly, we really should be separating the creation and execution of tools
561:              ;; We're only doing this because for synchronous tools we can't set the tool in the
562:              ;; hashmap after execution, because sync tools have already removed the key then.
563:              (placeholder-tool (make-greger-tool :cancel-fn nil)))
564: 
565:         (puthash tool-id placeholder-tool (greger-state-executing-tools state))
566: 
567:         (greger--update-buffer-state)
568:         (sit-for 0.001) ;; update the buffer state
569: 
570:         (let ((greger-tool (greger-tools-execute
571:                             :tool-name tool-name
572:                             :args tool-input
573:                             :callback (lambda (result error)
574:                                         ;; Remove tool from executing-tools when complete
575:                                         (remhash tool-id (greger-state-executing-tools state))
576: 
577:                                         (greger--handle-tool-completion
578:                                          :tool-id tool-id
579:                                          :result result
580:                                          :error error
581:                                          :state state
582:                                          :completion-callback (lambda ()
583:                                                                 (setq completed-tools (1+ completed-tools))
584:                                                                 (when (= completed-tools total-tools)
585:                                                                   (greger--run-agent-loop state)))))
586:                             :buffer (greger-state-chat-buffer state)
587:                             :metadata (greger-state-metadata state))))
588: 
589:           ;; TODO: here again, it's ugly
590:           (when (greger-tool-cancel-fn greger-tool)
591:             (puthash tool-id greger-tool (greger-state-executing-tools state))))))))
592: 
593: (defun greger--append-text (state text)
594:   "Append TEXT to the chat buffer in AGENT-STATE."
595:   (with-current-buffer (greger-state-chat-buffer state)
596:     (let ((inhibit-read-only t))
597:       (goto-char (point-max))
598:       (insert text))))
599: 
600: (cl-defun greger--handle-tool-completion (&key tool-id result error state completion-callback)
601:   "Handle completion of a tool execution by updating buffer and calling callback.
602: TOOL-ID is the tool identifier.
603: RESULT is the tool execution result.
604: ERROR is any error that occurred.
605: AGENT-STATE contains the current agent state.
606: COMPLETION-CALLBACK is called when complete."
607:   (let ((tool-result (if error
608:                         `((type . "tool_result")
609:                           (tool_use_id . ,tool-id)
610:                           (content . ,(if (stringp error)
611:                                          error
612:                                        (format "Error executing tool: %s" (error-message-string error))))
613:                           (is_error . t))
614:                       `((type . "tool_result")
615:                         (tool_use_id . ,tool-id)
616:                         (content . ,result)))))
617: 
618:     ;; Update the buffer at the correct position
619:     (with-current-buffer (greger-state-chat-buffer state)
620:       (let ((inhibit-read-only t))
621:         (save-excursion
622:           (goto-char (point-max))
623:           ;; Find and replace the placeholder
624:           (when (search-backward (greger--tool-placeholder tool-id) nil t)
625:             (replace-match "")
626:             (let ((result-markdown (greger-parser--content-blocks-to-markdown (list tool-result))))
627:               (unless (string-empty-p result-markdown)
628:                 (insert result-markdown)))))))
629: 
630:     ;; Update buffer state after tool completion
631:     (with-current-buffer (greger-state-chat-buffer state)
632:       (greger--update-buffer-state))
633: 
634:     ;; Call completion callback
635:     (funcall completion-callback)))
636: 
637: (defun greger--finish-response (state)
638:   "Finish the agent response using AGENT-STATE."
639:   (greger--debug "=== FINISHING RESPONSE - CONVERSATION COMPLETE ===")
640:   (with-current-buffer (greger-state-chat-buffer state)
641:     (let ((inhibit-read-only t))
642:       (goto-char (point-max))
643:       (unless (looking-back (concat greger-user-tag "\n\n") nil)
644:         (insert "\n\n" greger-user-tag "\n\n")))
645:     ;; Clear the buffer-local agent state
646:     (setq greger--current-state nil)
647:     ;; Update buffer state to idle
648:     (greger--update-buffer-state))
649:   ;; Reset the state
650:   (setf (greger-state-current-iteration state) 0)
651:   (setf (greger-state-client-state state) nil))
652: 
653: (defun greger-toggle-debug ()
654:   "Toggle debug output."
655:   (interactive)
656:   (setq greger-debug (not greger-debug))
657:   (message "Greger debug %s" (if greger-debug "enabled" "disabled")))
658: 
659: ;; Tool section collapsing functions
660: 
661: (defun greger--setup-tool-sections ()
662:   "Set up tool section highlighting and collapsing in the current buffer."
663:   (greger--clear-tool-overlays)
664:   (greger--find-and-setup-tool-sections))
665: 
666: (defun greger--clear-tool-overlays ()
667:   "Clear all tool section overlays in the current buffer."
668:   (cl-loop for overlay in greger-tool-overlays
669:            do (delete-overlay overlay))
670:   (setq greger-tool-overlays nil))
671: 
672: (defun greger--find-and-setup-tool-sections ()
673:   "Find all tool sections and set them up with appropriate faces and collapsing."
674:   (save-excursion
675:     (goto-char (point-min))
676:     (cl-loop while (re-search-forward "<tool\\.[^>]+>" nil t)
677:              do (greger--setup-single-tool-section))))
678: 
679: (defun greger--setup-single-tool-section ()
680:   "Set up a single tool section starting from the current match."
681:   (let ((start-tag-start (match-beginning 0))
682:         (start-tag-end (match-end 0))
683:         (tool-id (greger--extract-tool-id (match-string 0))))
684:     (when tool-id
685:       (let ((end-tag-pattern (concat "</tool\\." (regexp-quote tool-id) ">"))
686:             (content-start start-tag-end)
687:             content-end
688:             end-tag-start
689:             end-tag-end)
690: 
691:         ;; Find the corresponding closing tag
692:         (when (re-search-forward end-tag-pattern nil t)
693:           (setq end-tag-start (match-beginning 0)
694:                 end-tag-end (match-end 0)
695:                 content-end end-tag-start)
696: 
697:           ;; Create overlays for styling
698:           (greger--create-tag-overlay start-tag-start start-tag-end)
699:           (greger--create-tag-overlay end-tag-start end-tag-end)
700: 
701:           ;; Set up collapsible content
702:           (greger--setup-collapsible-content content-start content-end tool-id))))))
703: 
704: (defun greger--extract-tool-id (tag-string)
705:   "Extract tool ID from a tool tag string like '<tool.abc123>'.
706: TAG-STRING is the tag string to extract from."
707:   (when (string-match "<tool\\.\\([^>]+\\)>" tag-string)
708:     (match-string 1 tag-string)))
709: 
710: (defun greger--create-tag-overlay (start end)
711:   "Create an overlay for a tool tag to make it small and less visible.
712: START is the beginning position.
713: END is the ending position."
714:   (let ((overlay (make-overlay start end)))
715:     (overlay-put overlay 'face 'greger-tool-tag-face)
716:     (overlay-put overlay 'greger-tool-tag t)
717:     (push overlay greger-tool-overlays)
718:     overlay))
719: 
720: (defun greger--setup-collapsible-content (content-start content-end tool-id)
721:   "Set up collapsible content between CONTENT-START and CONTENT-END for TOOL-ID.
722: CONTENT-START is the start position of the content.
723: CONTENT-END is the end position of the content.
724: TOOL-ID is the tool identifier."
725:   (let* ((content (buffer-substring-no-properties content-start content-end))
726:          (lines (split-string content "\n"))
727:          (line-count (length lines)))
728: 
729:     (when (and (> line-count greger-tool-section-max-lines)
730:                ;; Only create collapsed overlay if not manually unfolded
731:                (not (member tool-id greger--unfolded-tool-ids)))
732:       ;; Create the collapsible overlay
733:       (greger--create-collapsible-overlay content-start content-end tool-id lines))))
734: 
735: (defun greger--create-collapsible-overlay (content-start content-end tool-id lines)
736:   "Create a collapsible overlay for tool content.
737: CONTENT-START and CONTENT-END define the overlay bounds.
738: TOOL-ID identifies the tool, and LINES contain the content."
739:   (let* ((visible-lines (cl-subseq lines 0 greger-tool-section-max-lines))
740:          (hidden-lines (cl-subseq lines greger-tool-section-max-lines))
741:          (hidden-line-count (length hidden-lines))
742:          (visible-text (mapconcat #'identity visible-lines "\n"))
743: 
744:          ;; Calculate positions for visible and hidden parts
745:          (visible-end (+ content-start (length visible-text)))
746:          (hidden-start (+ visible-end 1)) ; +1 for the newline
747: 
748:          ;; Create overlay for the hidden part
749:          (hidden-overlay (make-overlay hidden-start content-end)))
750: 
751:     (overlay-put hidden-overlay 'invisible 'greger-tool-section)
752:     (overlay-put hidden-overlay 'greger-tool-section t)
753:     (overlay-put hidden-overlay 'greger-tool-id tool-id)
754:     (overlay-put hidden-overlay 'greger-collapsed t)
755: 
756:     ;; Add expansion indicator with line count
757:     (let ((indicator-overlay (make-overlay visible-end visible-end)))
758:       (overlay-put indicator-overlay 'after-string
759:                    (propertize (format "... [+%d lines, TAB to expand]" hidden-line-count)
760:                               'face 'greger-tool-tag-face))
761:       (overlay-put indicator-overlay 'greger-tool-indicator t)
762:       (overlay-put indicator-overlay 'greger-tool-id tool-id)
763:       (push indicator-overlay greger-tool-overlays))
764: 
765:     (push hidden-overlay greger-tool-overlays)))
766: 
767: (defun greger-toggle-tool-section ()
768:   "Toggle the tool section at point between collapsed and expanded state.
769: If not inside a tool section, fall back to `markdown-cycle'."
770:   (interactive)
771:   (let ((tool-id (greger--get-tool-id-at-point)))
772:     (if tool-id
773:         (greger--toggle-tool-section-by-id tool-id)
774:       ;; Fall back to markdown-cycle if available
775:       (if (fboundp 'markdown-cycle)
776:           (call-interactively #'markdown-cycle)
777:         (message "Not inside a tool section")))))
778: 
779: (defun greger--get-tool-id-at-point ()
780:   "Get the tool ID for the tool section at point, if any."
781:   ;; First check overlays at point
782:   (or (cl-loop for overlay in (overlays-at (point))
783:                for tool-id = (overlay-get overlay 'greger-tool-id)
784:                when tool-id return tool-id)
785:       ;; If not found, search backwards and forwards for tool tags
786:       (greger--find-tool-id-near-point)))
787: 
788: (defun greger--find-tool-id-near-point ()
789:   "Find tool ID near point by searching for tool tags."
790:   (save-excursion
791:     (let ((start-pos (point))
792:           tool-id)
793:       ;; Search backwards for opening tag
794:       (when (re-search-backward "<tool\\.[^>]+>" nil t)
795:         (let ((open-tag-start (match-beginning 0))
796:               (tag-tool-id (greger--extract-tool-id (match-string 0))))
797:           ;; Check if we're within this tool section
798:           (when tag-tool-id
799:             (let ((close-pattern (concat "</tool\\." (regexp-quote tag-tool-id) ">")))
800:               (when (re-search-forward close-pattern nil t)
</tool.toolu_017a4MsmvYxP9YFdHyLL37J6>

## ASSISTANT:

Let me continue reading to see the rest of the tool section handling:

## TOOL USE:

Name: read-file
ID: toolu_01TWHCtL6h8qnRsLTLpxUnb1

### path

<tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>
greger.el
</tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>

### include-line-numbers

<tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>
true
</tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>

### start-line

<tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>
800
</tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>

### end-line

<tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>
1200
</tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>

## TOOL RESULT:

ID: toolu_01TWHCtL6h8qnRsLTLpxUnb1

<tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>
800:               (when (re-search-forward close-pattern nil t)
801:                 (let ((close-tag-end (match-end 0)))
802:                   ;; If original point is between open and close tags
803:                   (when (and (>= start-pos open-tag-start)
804:                              (<= start-pos close-tag-end))
805:                     (setq tool-id tag-tool-id))))))))
806:       tool-id)))
807: 
808: (defun greger--toggle-tool-section-by-id (tool-id)
809:   "Toggle the tool section with the given TOOL-ID.
810: TOOL-ID is the identifier of the tool section to toggle."
811:   (cl-loop for overlay in greger-tool-overlays
812:            when (and (overlay-get overlay 'greger-tool-section)
813:                      (string= (overlay-get overlay 'greger-tool-id) tool-id))
814:            do (greger--toggle-overlay-visibility overlay tool-id)))
815: 
816: (defun greger--toggle-overlay-visibility (overlay tool-id)
817:   "Toggle the visibility of OVERLAY for TOOL-ID."
818:   (let ((is-collapsed (overlay-get overlay 'greger-collapsed)))
819:     (if is-collapsed
820:         (greger--expand-tool-section overlay tool-id)
821:       (greger--collapse-tool-section overlay tool-id))))
822: 
823: (defun greger--expand-tool-section (overlay tool-id)
824:   "Expand the tool section by making OVERLAY visible.
825: OVERLAY is the overlay to expand, TOOL-ID identifies the tool."
826:   (overlay-put overlay 'invisible nil)
827:   (overlay-put overlay 'greger-collapsed nil)
828: 
829:   ;; Mark this tool as manually unfolded so it doesn't get auto-folded again
830:   (unless (member tool-id greger--unfolded-tool-ids)
831:     (push tool-id greger--unfolded-tool-ids))
832: 
833:   ;; Remove the expansion indicator
834:   (cl-loop for indicator-overlay in greger-tool-overlays
835:            when (and (overlay-get indicator-overlay 'greger-tool-indicator)
836:                      (string= (overlay-get indicator-overlay 'greger-tool-id) tool-id))
837:            do (progn
838:                 (delete-overlay indicator-overlay)
839:                 (setq greger-tool-overlays
840:                       (remove indicator-overlay greger-tool-overlays)))))
841: 
842: (defun greger--collapse-tool-section (overlay tool-id)
843:   "Collapse the tool section by making OVERLAY invisible.
844: OVERLAY is the overlay to hide.
845: TOOL-ID is the tool identifier."
846:   (overlay-put overlay 'invisible 'greger-tool-section)
847:   (overlay-put overlay 'greger-collapsed t)
848: 
849:   ;; Remove from unfolded list since it's now manually collapsed
850:   (setq greger--unfolded-tool-ids
851:         (delete tool-id greger--unfolded-tool-ids))
852: 
853:   ;; Calculate the number of hidden lines for the indicator
854:   (let* ((content (buffer-substring-no-properties (overlay-start overlay) (overlay-end overlay)))
855:          (lines (split-string content "\n"))
856:          (hidden-line-count (length lines))
857:          (overlay-start (overlay-start overlay))
858:          (indicator-pos (max (point-min) (1- overlay-start)))
859:          (indicator-overlay (make-overlay indicator-pos indicator-pos)))
860:     (overlay-put indicator-overlay 'after-string
861:                  (propertize (format "... [+%d lines, TAB to expand]" hidden-line-count)
862:                             'face 'greger-tool-tag-face))
863:     (overlay-put indicator-overlay 'greger-tool-indicator t)
864:     (overlay-put indicator-overlay 'greger-tool-id tool-id)
865:     (push indicator-overlay greger-tool-overlays)))
866: 
867: (defun greger--setup-heading-font-lock ()
868:   "Set up font-lock for headings to override markdown's larger font sizes."
869:   ;; Remove existing markdown heading font-lock rules for level 2 and 3 headings
870:   (setq-local font-lock-keywords
871:               (cl-remove-if
872:                (lambda (rule)
873:                  (and (listp rule)
874:                       (stringp (car rule))
875:                       (or (string-match-p "^\\^##" (car rule))
876:                           (string-match-p "^\\^###" (car rule))
877:                           (string-match-p "markdown-header-face-[23]" (format "%s" rule)))))
878:                font-lock-keywords))
879: 
880:   ;; Add our custom font-lock rules with highest priority
881:   (font-lock-add-keywords
882:    nil
883:    '(;; Level 2 headings (conversation roles)
884:      ("^## USER:.*$" 0 'greger-user-heading-face t)
885:      ("^## ASSISTANT:.*$" 0 'greger-assistant-heading-face t)
886:      ("^## SYSTEM:.*$" 0 'greger-system-heading-face t)
887:      ("^## THINKING:.*$" 0 'greger-thinking-heading-face t)
888:      ("^## TOOL USE:.*$" 0 'greger-tool-use-heading-face t)
889:      ("^## TOOL RESULT:.*$" 0 'greger-tool-result-heading-face t)
890:      ;; Level 3 headings (tool parameters)
891:      ("^###\\s-+.*$" 0 'greger-tool-param-heading-face t))
892:    'prepend)
893: 
894:   ;; Also remap the markdown faces
895:   ;(face-remap-add-relative 'markdown-header-face-2 'greger-assistant-heading-face)
896:   ;(face-remap-add-relative 'markdown-header-face-3 'greger-tool-param-heading-face)
897:   (font-lock-flush))
898: 
899: (defun greger--extend-font-lock-region ()
900:   "Extend font-lock region for greger mode.
901: Returns nil to indicate no region extension is needed."
902:   nil)
903: 
904: (defun greger--after-change-function (beg end _len)
905:   "Update tool sections after buffer changes.
906: BEG is the beginning of the changed region.
907: END is the end of the changed region.
908: _LEN is the length of the pre-change text (unused)."
909:   ;; Only run timer-based cleanup for complex changes or when not actively streaming
910:   (when (and (> (- end beg) 0)  ; Only if there was an actual change
911:              (not (greger--is-actively-streaming)))
912:     (run-with-idle-timer 0.1 nil #'greger--setup-tool-sections)))
913: 
914: (defun greger--is-actively-streaming ()
915:   "Check if we're currently streaming content from the AI."
916:   (and greger--current-state
917:        (greger-state-client-state greger--current-state)))
918: 
919: ;; Private helper functions
920: 
921: (defun greger--get-current-code-block ()
922:   "Return the current code block under point, or nil if not found."
923:   (save-excursion
924:     (when (re-search-backward "^```" nil t)
925:       (forward-line)
926:       (let ((start (point)))
927:         (when (re-search-forward "^```" nil t)
928:           (backward-char 4)
929:           (buffer-substring-no-properties start (point)))))))
930: 
931: (defun greger--truncate-with-ellipsis (str max-width)
932:   "Truncate STR to MAX-WIDTH characters, adding an ellipsis if necessary."
933:   (let ((len (length str)))
934:     (if (<= len max-width)
935:         str
936:       (concat (substring str 0 (- max-width 3)) "..."))))
937: 
938: 
939: 
940: (provide 'greger)
941: 
942: ;;; greger.el ends here
</tool.toolu_01TWHCtL6h8qnRsLTLpxUnb1>

## ASSISTANT:

Now let me look at some test files to understand the citation format better:

## TOOL USE:

Name: read-file
ID: toolu_01XeX3iafb6j9WLeevrbF4G8

### path

<tool.toolu_01XeX3iafb6j9WLeevrbF4G8>
test-citations-output.el
</tool.toolu_01XeX3iafb6j9WLeevrbF4G8>

## TOOL RESULT:

ID: toolu_01XeX3iafb6j9WLeevrbF4G8

<tool.toolu_01XeX3iafb6j9WLeevrbF4G8>
#!/usr/bin/env emacs --script

;; Add current directory to load path
(add-to-list 'load-path ".")

;; Load required modules
(require 'greger-parser)

;; Test markdown with citations
(let* ((markdown "## USER:

When was Claude Shannon born?

## SERVER TOOL USE:

Name: web_search
ID: srvtoolu_01WYG3ziw53XMcoyKL4XcZmE

### query

<tool.srvtoolu_01WYG3ziw53XMcoyKL4XcZmE>
claude shannon birth date
</tool.srvtoolu_01WYG3ziw53XMcoyKL4XcZmE>

## SERVER TOOL RESULT:

ID: srvtoolu_01WYG3ziw53XMcoyKL4XcZmE

<tool.srvtoolu_01WYG3ziw53XMcoyKL4XcZmE>
[
  {
    \"type\": \"web_search_result\",
    \"url\": \"https://en.wikipedia.org/wiki/Claude_Shannon\",
    \"title\": \"Claude Shannon - Wikipedia\",
    \"encrypted_content\": \"EqgfCioIARgBIiQ3YTAwMjY1Mi1mZjM5LTQ1NGUtODgxNC1kNjNjNTk1ZWI3Y...\",
    \"page_age\": \"April 30, 2025\"
  }
]
</tool.srvtoolu_01WYG3ziw53XMcoyKL4XcZmE>

## ASSISTANT:

Based on the search results, <cite>Claude Shannon was born on April 30, 1916, in Petoskey, Michigan</cite>

## CITATIONS:

### https://en.wikipedia.org/wiki/Claude_Shannon

Title: Claude Shannon - Wikipedia
Cited text: Claude Elwood Shannon (April 30, 1916 â€“ February 24, 2001) was an American mathematician, electrical engineer, computer scientist, cryptographer and i...
Encrypted index: Eo8BCioIAhgBIiQyYjQ0OWJmZi1lNm..")
       ;; Parse the dialog
       (parsed (greger-parser-parse-dialog markdown))
       ;; Convert back to markdown
       (roundtrip (greger-parser-dialog-to-markdown (plist-get parsed :messages))))

  (princ "=== ORIGINAL MARKDOWN ===\n")
  (princ markdown)
  (princ "\n\n=== PARSED STRUCTURE ===\n")
  (princ (format "%S" parsed))
  (princ "\n\n=== ROUNDTRIP MARKDOWN ===\n")
  (princ roundtrip)
  (princ "\n"))
</tool.toolu_01XeX3iafb6j9WLeevrbF4G8>

## ASSISTANT:

Let me also look at the existing test files to understand the current streaming structure:

## TOOL USE:

Name: ripgrep
ID: toolu_015MRX3NuwTM1SCiaZ1y87JF

### pattern

<tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>
citations_delta
</tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>

### path

<tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>
test
</tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>

## TOOL RESULT:

ID: toolu_015MRX3NuwTM1SCiaZ1y87JF

<tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>
Failed to execute ripgrep search: Command failed with exit code 1: (no output)
</tool.toolu_015MRX3NuwTM1SCiaZ1y87JF>

## TOOL USE:

Name: ripgrep
ID: toolu_01Pdx3CZ3doABukUsnAJUmaK

### pattern

<tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>
citation
</tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>

### path

<tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>
.
</tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>

## TOOL RESULT:

ID: toolu_01Pdx3CZ3doABukUsnAJUmaK

<tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>
/Users/andreas/projects/greger.el/greger-parser.el:43:(defconst greger-parser-citations-tag "## CITATIONS:")
/Users/andreas/projects/greger.el/greger-parser.el:216:        greger-parser-citations-tag
/Users/andreas/projects/greger.el/greger-parser.el:615:                 ;; Handle citations data - store for later processing
/Users/andreas/projects/greger.el/greger-parser.el:616:                 ((and (listp section-result) (eq (plist-get section-result :type) :citations-data))
/Users/andreas/projects/greger.el/greger-parser.el:617:                  (greger-parser--debug state "Found citations data, storing for later processing")
/Users/andreas/projects/greger.el/greger-parser.el:618:                  (setq metadata (append metadata (list :pending-citations (plist-get section-result :citations)))))
/Users/andreas/projects/greger.el/greger-parser.el:634:             (pending-citations (plist-get combined-metadata :pending-citations)))
/Users/andreas/projects/greger.el/greger-parser.el:635:        ;; Apply pending citations if any
/Users/andreas/projects/greger.el/greger-parser.el:636:        (when pending-citations
/Users/andreas/projects/greger.el/greger-parser.el:637:          (greger-parser--apply-citations-to-messages merged-messages pending-citations)
/Users/andreas/projects/greger.el/greger-parser.el:638:          ;; Remove pending citations from metadata since they've been applied
/Users/andreas/projects/greger.el/greger-parser.el:639:          (setq combined-metadata (greger-parser--remove-from-plist combined-metadata :pending-citations)))
/Users/andreas/projects/greger.el/greger-parser.el:663:       ((string= tag greger-parser-citations-tag)
/Users/andreas/projects/greger.el/greger-parser.el:664:        (greger-parser--parse-citations-section state))
/Users/andreas/projects/greger.el/greger-parser.el:733:(defun greger-parser--parse-citations-section (state)
/Users/andreas/projects/greger.el/greger-parser.el:734:  "Parse CITATIONS section using STATE.
/Users/andreas/projects/greger.el/greger-parser.el:735:Returns parsed citation data that should be merged with the previous assistant message."
/Users/andreas/projects/greger.el/greger-parser.el:738:      ;; Parse the citations from the markdown content
/Users/andreas/projects/greger.el/greger-parser.el:739:      (let ((parsed-citations (greger-parser--parse-citations-content content)))
/Users/andreas/projects/greger.el/greger-parser.el:740:        ;; Return a special marker indicating this contains citation data
/Users/andreas/projects/greger.el/greger-parser.el:742:        (list :type :citations-data :citations parsed-citations)))))
/Users/andreas/projects/greger.el/greger-parser.el:744:(defun greger-parser--parse-citations-content (content)
/Users/andreas/projects/greger.el/greger-parser.el:745:  "Parse citations from markdown CONTENT and return list of citation objects."
/Users/andreas/projects/greger.el/greger-parser.el:746:  (let ((citations '())
/Users/andreas/projects/greger.el/greger-parser.el:748:        (current-citation nil)
/Users/andreas/projects/greger.el/greger-parser.el:754:        ;; Save previous citation if any
/Users/andreas/projects/greger.el/greger-parser.el:755:        (when current-citation
/Users/andreas/projects/greger.el/greger-parser.el:756:          (push current-citation citations))
/Users/andreas/projects/greger.el/greger-parser.el:757:        ;; Start new citation
/Users/andreas/projects/greger.el/greger-parser.el:759:        (setq current-citation (list (cons 'type "web_search_result_location")
/Users/andreas/projects/greger.el/greger-parser.el:762:       ((and current-citation (string-match "^Title: \\(.*\\)" line))
/Users/andreas/projects/greger.el/greger-parser.el:763:        (push (cons 'title (match-string 1 line)) current-citation))
/Users/andreas/projects/greger.el/greger-parser.el:765:       ((and current-citation (string-match "^Cited text: \\(.*\\)" line))
/Users/andreas/projects/greger.el/greger-parser.el:766:        (push (cons 'cited_text (match-string 1 line)) current-citation))
/Users/andreas/projects/greger.el/greger-parser.el:768:       ((and current-citation (string-match "^Encrypted index: \\(.*\\)" line))
/Users/andreas/projects/greger.el/greger-parser.el:769:        (push (cons 'encrypted_index (match-string 1 line)) current-citation))))
/Users/andreas/projects/greger.el/greger-parser.el:770:    ;; Add the last citation
/Users/andreas/projects/greger.el/greger-parser.el:771:    (when current-citation
/Users/andreas/projects/greger.el/greger-parser.el:772:      (push current-citation citations))
/Users/andreas/projects/greger.el/greger-parser.el:773:    (reverse citations)))
/Users/andreas/projects/greger.el/greger-parser.el:775:(defun greger-parser--merge-citations-with-last-assistant (sections citations)
/Users/andreas/projects/greger.el/greger-parser.el:776:  "Merge CITATIONS with the last assistant message in SECTIONS list.
/Users/andreas/projects/greger.el/greger-parser.el:778:  (when (and sections citations)
/Users/andreas/projects/greger.el/greger-parser.el:781:        ;; Find text blocks in the content and add citations to them
/Users/andreas/projects/greger.el/greger-parser.el:784:            ;; Look for text blocks and add citations
/Users/andreas/projects/greger.el/greger-parser.el:785:            (greger-parser--add-citations-to-content-blocks content citations)))))))
/Users/andreas/projects/greger.el/greger-parser.el:787:(defun greger-parser--add-citations-to-content-blocks (content-blocks citations)
/Users/andreas/projects/greger.el/greger-parser.el:788:  "Add CITATIONS to appropriate text blocks in CONTENT-BLOCKS.
/Users/andreas/projects/greger.el/greger-parser.el:789:Splits text blocks at <cite> boundaries and adds citations to cited portions."
/Users/andreas/projects/greger.el/greger-parser.el:797:              (let ((split-blocks (greger-parser--split-text-with-citations text citations)))
/Users/andreas/projects/greger.el/test-citations-output.el:9:;; Test markdown with citations
/Users/andreas/projects/greger.el/test-citations-output.el:45:## CITATIONS:
/Users/andreas/projects/greger.el/debug-citations-immediate.el:10:(defun greger-parser--apply-citations-to-messages (messages citations)
/Users/andreas/projects/greger.el/debug-citations-immediate.el:11:  "Apply CITATIONS to the last assistant message in MESSAGES that contains <cite> tags."
/Users/andreas/projects/greger.el/debug-citations-immediate.el:12:  (message "DEBUG: Apply citations called with %d citations" (length citations))
/Users/andreas/projects/greger.el/debug-citations-immediate.el:13:  ;; Find the last assistant message and apply citations to it
/Users/andreas/projects/greger.el/debug-citations-immediate.el:28:          (greger-parser--add-citations-to-content-blocks content citations)
/Users/andreas/projects/greger.el/debug-citations-immediate.el:30:          (message "DEBUG: Message after citation processing: %S" message))))))
/Users/andreas/projects/greger.el/debug-citations-immediate.el:32:;; Test markdown with citations
/Users/andreas/projects/greger.el/debug-citations-immediate.el:41:## CITATIONS:
/Users/andreas/projects/greger.el/test/test-greger-parser.el:667:    ;; Citation parsing test cases
/Users/andreas/projects/greger.el/test/test-greger-parser.el:668:    (:name "citations-basic"
/Users/andreas/projects/greger.el/test/test-greger-parser.el:704:## CITATIONS:
/Users/andreas/projects/greger.el/test/test-greger-parser.el:725:                                                       (citations . (((type . "web_search_result_location")
/Users/andreas/projects/greger.el/test/test-greger-parser.el:731:    ;; Citations immediately after tool result
/Users/andreas/projects/greger.el/test/test-greger-parser.el:732:    (:name "citations-after-tool-result"
/Users/andreas/projects/greger.el/test/test-greger-parser.el:768:## CITATIONS:
/Users/andreas/projects/greger.el/test/test-greger-parser.el:789:                                                       (citations . (((type . "web_search_result_location")
/Users/andreas/projects/greger.el/test/test-greger-parser.el:795:    ;; Multiple citations in same text
/Users/andreas/projects/greger.el/test/test-greger-parser.el:796:    (:name "citations-multiple"
/Users/andreas/projects/greger.el/test/test-greger-parser.el:839:## CITATIONS:
/Users/andreas/projects/greger.el/test/test-greger-parser.el:871:                                                       (citations . (((type . "web_search_result_location")
/Users/andreas/projects/greger.el/test/test-greger-parser.el:879:                                                       (citations . (((type . "web_search_result_location")
/Users/andreas/projects/greger.el/debug-citations-verbose.el:9:;; Test markdown with citations
/Users/andreas/projects/greger.el/debug-citations-verbose.el:45:## CITATIONS:
/Users/andreas/projects/greger.el/chat.ai:17:I've made a small start at adding support for citations in greger-parser.el. Finish the implementation.
/Users/andreas/projects/greger.el/chat.ai:19:Citations are used in web search tool results, documented here: https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool.md
/Users/andreas/projects/greger.el/chat.ai:21:Note that the citations are folded up with the assistant message.
/Users/andreas/projects/greger.el/chat.ai:61:## CITATIONS:
/Users/andreas/projects/greger.el/chat.ai:70:followed by potentially other citations in the form
/Users/andreas/projects/greger.el/chat.ai:84:* The text in the list item with the citations object is wrapped in `<cite>`, but otherwise folded into the previous ASSISTANT: section.
/Users/andreas/projects/greger.el/chat.ai:86:I have a broken implementaiton that you've already started in greger-parser.el and a test case in test-greger-parser.el. Don't modify the existing test case but add other ones once you've fixed greger-parser.el so that that one existing test works. Tests with variations, e.g. if the list item with citations isn't preceded by a type:text item but immediately follows the web_search_tool_result.
/Users/andreas/projects/greger.el/chat.ai:92:I'll help you finish the implementation for citations in greger-parser.el. Let me first examine the current state of the code and the test case to understand what needs to be fixed.
/Users/andreas/projects/greger.el/chat.ai:158:  43: (defconst greger-parser-citations-tag "## CITATIONS:")
/Users/andreas/projects/greger.el/chat.ai:331: 216:         greger-parser-citations-tag
/Users/andreas/projects/greger.el/chat.ai:730: 615:                  ;; Handle citations data - store for later processing
/Users/andreas/projects/greger.el/chat.ai:731: 616:                  ((and (listp section-result) (eq (plist-get section-result :type) :citations-data))
/Users/andreas/projects/greger.el/chat.ai:732: 617:                   (greger-parser--debug state "Found citations data, storing for later processing")
/Users/andreas/projects/greger.el/chat.ai:733: 618:                   (setq metadata (append metadata (list :pending-citations (plist-get section-result :citations)))))
/Users/andreas/projects/greger.el/chat.ai:749: 634:              (pending-citations (plist-get combined-metadata :pending-citations)))
/Users/andreas/projects/greger.el/chat.ai:750: 635:         ;; Apply pending citations if any
/Users/andreas/projects/greger.el/chat.ai:751: 636:         (when pending-citations
/Users/andreas/projects/greger.el/chat.ai:752: 637:           (greger-parser--apply-citations-to-messages merged-messages pending-citations)
/Users/andreas/projects/greger.el/chat.ai:753: 638:           ;; Remove pending citations from metadata since they've been applied
/Users/andreas/projects/greger.el/chat.ai:754: 639:           (setq combined-metadata (greger-parser--remove-from-plist combined-metadata :pending-citations)))
/Users/andreas/projects/greger.el/chat.ai:778: 663:        ((string= tag greger-parser-citations-tag)
/Users/andreas/projects/greger.el/chat.ai:779: 664:         (greger-parser--parse-citations-section state))
/Users/andreas/projects/greger.el/chat.ai:848: 733: (defun greger-parser--parse-citations-section (state)
/Users/andreas/projects/greger.el/chat.ai:849: 734:   "Parse CITATIONS section using STATE.
/Users/andreas/projects/greger.el/chat.ai:850: 735: Returns parsed citation data that should be merged with the previous assistant message."
/Users/andreas/projects/greger.el/chat.ai:853: 738:       ;; Parse the citations from the markdown content
/Users/andreas/projects/greger.el/chat.ai:854: 739:       (let ((parsed-citations (greger-parser--parse-citations-content content)))
/Users/andreas/projects/greger.el/chat.ai:855: 740:         ;; Return a special marker indicating this contains citation data
/Users/andreas/projects/greger.el/chat.ai:857: 742:         (list :type :citations-data :citations parsed-citations)))))
/Users/andreas/projects/greger.el/chat.ai:859: 744: (defun greger-parser--parse-citations-content (content)
/Users/andreas/projects/greger.el/chat.ai:860: 745:   "Parse citations from markdown CONTENT and return list of citation objects."
/Users/andreas/projects/greger.el/chat.ai:861: 746:   (let ((citations '())
/Users/andreas/projects/greger.el/chat.ai:863: 748:         (current-citation nil)
/Users/andreas/projects/greger.el/chat.ai:869: 754:         ;; Save previous citation if any
/Users/andreas/projects/greger.el/chat.ai:870: 755:         (when current-citation
/Users/andreas/projects/greger.el/chat.ai:871: 756:           (push current-citation citations))
/Users/andreas/projects/greger.el/chat.ai:872: 757:         ;; Start new citation
/Users/andreas/projects/greger.el/chat.ai:874: 759:         (setq current-citation (list (cons 'type "web_search_result_location")
/Users/andreas/projects/greger.el/chat.ai:877: 762:        ((and current-citation (string-match "^Title: \\(.*\\)" line))
/Users/andreas/projects/greger.el/chat.ai:878: 763:         (push (cons 'title (match-string 1 line)) current-citation))
/Users/andreas/projects/greger.el/chat.ai:880: 765:        ((and current-citation (string-match "^Cited text: \\(.*\\)" line))
/Users/andreas/projects/greger.el/chat.ai:881: 766:         (push (cons 'cited_text (match-string 1 line)) current-citation))
/Users/andreas/projects/greger.el/chat.ai:883: 768:        ((and current-citation (string-match "^Encrypted index: \\(.*\\)" line))
/Users/andreas/projects/greger.el/chat.ai:884: 769:         (push (cons 'encrypted_index (match-string 1 line)) current-citation))))
/Users/andreas/projects/greger.el/chat.ai:885: 770:     ;; Add the last citation
/Users/andreas/projects/greger.el/chat.ai:886: 771:     (when current-citation
/Users/andreas/projects/greger.el/chat.ai:887: 772:       (push current-citation citations))
/Users/andreas/projects/greger.el/chat.ai:888: 773:     (reverse citations)))
/Users/andreas/projects/greger.el/chat.ai:890: 775: (defun greger-parser--merge-citations-with-last-assistant (sections citations)
/Users/andreas/projects/greger.el/chat.ai:891: 776:   "Merge CITATIONS with the last assistant message in SECTIONS list.

</tool.toolu_01Pdx3CZ3doABukUsnAJUmaK>

## ASSISTANT:

Now let me examine the actual streaming data structure provided in the user's message more carefully. The user is saying that `citations_delta` events need to be handled. Let me look at the expected citations format from the documentation they referenced:

## TOOL USE:

Name: read-webpage
ID: toolu_01H5cThGuZoCjGF7fjF3Uwm3

### url

<tool.toolu_01H5cThGuZoCjGF7fjF3Uwm3>
https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool.md
</tool.toolu_01H5cThGuZoCjGF7fjF3Uwm3>

## TOOL RESULT:

ID: toolu_01H5cThGuZoCjGF7fjF3Uwm3

<tool.toolu_01H5cThGuZoCjGF7fjF3Uwm3>
# Web search tool

The web search tool gives Claude direct access to real-time web content, allowing it to answer questions with up-to-date information beyond its knowledge cutoff. Claude automatically cites sources from search results as part of its answer.

 
  Please reach out through our [feedback form](https://forms.gle/sWjBtsrNEY2oKGuE8) to share your experience with the web search tool.
 

## Supported models

Web search is available on:

* Claude Opus 4 (`claude-opus-4-20250514`)
* Claude Sonnet 4 (`claude-sonnet-4-20250514`)
* Claude Sonnet 3.7 (`claude-3-7-sonnet-20250219`)
* Claude Sonnet 3.5 (new) (`claude-3-5-sonnet-latest`)
* Claude Haiku 3.5 (`claude-3-5-haiku-latest`)

## How web search works

When you add the web search tool to your API request:

1. Claude decides when to search based on the prompt.
2. The API executes the searches and provides Claude with the results. This process may repeat multiple times throughout a single request.
3. At the end of its turn, Claude provides a final response with cited sources.

## How to use web search

 
  Your organization's administrator must enable web search in [Console](https://console.anthropic.com/settings/privacy).
 

Provide the web search tool in your API request:

 
  ```bash Shell
  curl https://api.anthropic.com/v1/messages \
      --header "x-api-key: $ANTHROPIC_API_KEY" \
      --header "anthropic-version: 2023-06-01" \
      --header "content-type: application/json" \
      --data '{
          "model": "claude-opus-4-20250514",
          "max_tokens": 1024,
          "messages": [
              {
                  "role": "user",
                  "content": "How do I update a web app to TypeScript 5.5?"
              }
          ],
          "tools": [{
              "type": "web_search_20250305",
              "name": "web_search",
              "max_uses": 5
          }]
      }'
  ```

  ```python Python
  import anthropic

  client = anthropic.Anthropic()

  response = client.messages.create(
      model="claude-opus-4-20250514",
      max_tokens=1024,
      messages=[
          {
              "role": "user",
              "content": "How do I update a web app to TypeScript 5.5?"
          }
      ],
      tools=[{
          "type": "web_search_20250305",
          "name": "web_search",
          "max_uses": 5
      }]
  )
  print(response)
  ```

  ```typescript TypeScript
  import { Anthropic } from '@anthropic-ai/sdk';

  const anthropic = new Anthropic();

  async function main() {
    const response = await anthropic.messages.create({
      model: "claude-opus-4-20250514",
      max_tokens: 1024,
      messages: [
        {
          role: "user",
          content: "How do I update a web app to TypeScript 5.5?"
        }
      ],
      tools: [{
        type: "web_search_20250305",
        name: "web_search",
        max_uses: 5
      }]
    });

    console.log(response);
  }

  main().catch(console.error);
  ```
 

### Tool definition

The web search tool supports the following parameters:

```json JSON
{
  "type": "web_search_20250305",
  "name": "web_search",

  // Optional: Limit the number of searches per request
  "max_uses": 5,

  // Optional: Only include results from these domains
  "allowed_domains": ["example.com", "trusteddomain.org"],

  // Optional: Never include results from these domains
  "blocked_domains": ["untrustedsource.com"],

  // Optional: Localize search results
  "user_location": {
    "type": "approximate",
    "city": "San Francisco",
    "region": "California",
    "country": "US",
    "timezone": "America/Los_Angeles"
  }
}
```

#### Max uses

The `max_uses` parameter limits the number of searches performed. If Claude attempts more searches than allowed, the `web_search_tool_result` will be an error with the `max_uses_exceeded` error code.

#### Domain filtering

When using domain filters:

* Domains should not include the HTTP/HTTPS scheme (use `example.com` instead of `https://example.com`)
* Subdomains are automatically included (`example.com` covers `docs.example.com`)
* Subpaths are supported (`example.com/blog`)
* You can use either `allowed_domains` or `blocked_domains`, but not both in the same request.

#### Localization

The `user_location` parameter allows you to localize search results based on a user's location.

* `type`: The type of location (must be `approximate`)
* `city`: The city name
* `region`: The region or state
* `country`: The country
* `timezone`: The [IANA timezone ID](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).

### Response

Here's an example response structure:

```json
{
  "role": "assistant",
  "content": [
    // 1. Claude's decision to search
    {
      "type": "text",
      "text": "I'll search for when Claude Shannon was born."
    },
    // 2. The search query used
    {
      "type": "server_tool_use",
      "id": "srvtoolu_01WYG3ziw53XMcoyKL4XcZmE",
      "name": "web_search",
      "input": {
        "query": "claude shannon birth date"
      }
    },
    // 3. Search results
    {
      "type": "web_search_tool_result",
      "tool_use_id": "srvtoolu_01WYG3ziw53XMcoyKL4XcZmE",
      "content": [
        {
          "type": "web_search_result",
          "url": "https://en.wikipedia.org/wiki/Claude_Shannon",
          "title": "Claude Shannon - Wikipedia",
          "encrypted_content": "EqgfCioIARgBIiQ3YTAwMjY1Mi1mZjM5LTQ1NGUtODgxNC1kNjNjNTk1ZWI3Y...",
          "page_age": "April 30, 2025"
        }
      ]
    },
    {
      "text": "Based on the search results, ",
      "type": "text"
    },
    // 4. Claude's response with citations
    {
      "text": "Claude Shannon was born on April 30, 1916, in Petoskey, Michigan",
      "type": "text",
      "citations": [
        {
          "type": "web_search_result_location",
          "url": "https://en.wikipedia.org/wiki/Claude_Shannon",
          "title": "Claude Shannon - Wikipedia",
          "encrypted_index": "Eo8BCioIAhgBIiQyYjQ0OWJmZi1lNm..",
          "cited_text": "Claude Elwood Shannon (April 30, 1916 â€“ February 24, 2001) was an American mathematician, electrical engineer, computer scientist, cryptographer and i..."
        }
      ]
    }
  ],
  "id": "msg_a930390d3a",
  "usage": {
    "input_tokens": 6039,
    "output_tokens": 931,
    "server_tool_use": {
      "web_search_requests": 1
    }
  },
  "stop_reason": "end_turn"
}
```

#### Search results

Search results include:

* `url`: The URL of the source page
* `title`: The title of the source page
* `page_age`: When the site was last updated
* `encrypted_content`: Encrypted content that must be passed back in multi-turn conversations for citations

#### Citations

Citations are always enabled for web search, and each `web_search_result_location` includes:

* `url`: The URL of the cited source
* `title`: The title of the cited source
* `encrypted_index`: A reference that must be passed back for multi-turn conversations.
* `cited_text`: Up to 150 characters of the cited content

The web search citation fields `cited_text`, `title`, and `url` do not count towards input or output token usage.

 
  When displaying web results or information contained in web results to end users, inline citations must be made clearly visible and clickable in your user interface.
 

#### Errors

If an error occurs during web search, you'll receive a response that takes the following form:

```json
{
  "type": "web_search_tool_result",
  "tool_use_id": "servertoolu_a93jad",
  "content": {
    "type": "web_search_tool_result_error",
    "error_code": "max_uses_exceeded"
  }
}
```

These are the possible error codes:

* `too_many_requests`: Rate limit exceeded
* `invalid_input`: Invalid search query parameter
* `max_uses_exceeded`: Maximum web search tool uses exceeded
* `query_too_long`: Query exceeds maximum length
* `unavailable`: An internal error occurred

#### `pause_turn` stop reason

The response may include a `pause_turn` stop reason, which indicates that the API paused a long-running turn. You may provide the response back as-is in a subsequent request to let Claude continue its turn, or modify the content if you wish to interrupt the conversation.

## Prompt caching

Web search works with [prompt caching](/en/docs/build-with-claude/prompt-caching). To enable prompt caching, add at least one `cache_control` breakpoint in your request. The system will automatically cache up until the last `web_search_tool_result` block when executing the tool.

For multi-turn conversations, set a `cache_control` breakpoint on or after the last `web_search_tool_result` block to reuse cached content.

For example, to use prompt caching with web search for a multi-turn conversation:

 
  ```python
  import anthropic

  client = anthropic.Anthropic()

  # First request with web search and cache breakpoint
  messages = [
      {
          "role": "user",
          "content": "What's the current weather in San Francisco today?"
      }
  ]

  response1 = client.messages.create(
      model="claude-opus-4-20250514",
      max_tokens=1024,
      messages=messages,
      tools=[{
          "type": "web_search_20250305",
          "name": "web_search",
          "user_location": {
              "type": "approximate",
              "city": "San Francisco",
              "region": "California",
              "country": "US",
              "timezone": "America/Los_Angeles"
          }
      }]
  )

  # Add Claude's response to the conversation
  messages.append({
      "role": "assistant",
      "content": response1.content
  })

  # Second request with cache breakpoint after the search results
  messages.append({
      "role": "user",
      "content": "Should I expect rain later this week?",
      "cache_control": {"type": "ephemeral"}  # Cache up to this point
  })

  response2 = client.messages.create(
      model="claude-opus-4-20250514",
      max_tokens=1024,
      messages=messages,
      tools=[{
          "type": "web_search_20250305",
          "name": "web_search",
          "user_location": {
              "type": "approximate",
              "city": "San Francisco",
              "region": "California",
              "country": "US",
              "timezone": "America/Los_Angeles"
          }
      }]
  )
  # The second response will benefit from cached search results
  # while still being able to perform new searches if needed
  print(f"Cache read tokens: {response2.usage.get('cache_read_input_tokens', 0)}")
  ```
 

## Streaming

With streaming enabled, you'll receive search events as part of the stream. There will be a pause while the search executes:

```javascript
event: message_start
data: {"type": "message_start", "message": {"id": "msg_abc123", "type": "message"}}

event: content_block_start
data: {"type": "content_block_start", "index": 0, "content_block": {"type": "text", "text": ""}}

// Claude's decision to search

event: content_block_start
data: {"type": "content_block_start", "index": 1, "content_block": {"type": "server_tool_use", "id": "srvtoolu_xyz789", "name": "web_search"}}

// Search query streamed
event: content_block_delta
data: {"type": "content_block_delta", "index": 1, "delta": {"type": "input_json_delta", "partial_json": "{\"query\":\"latest quantum computing breakthroughs 2025\"}"}}

// Pause while search executes

// Search results streamed
event: content_block_start
data: {"type": "content_block_start", "index": 2, "content_block": {"type": "web_search_tool_result", "tool_use_id": "srvtoolu_xyz789", "content": [{"type": "web_search_result", "title": "Quantum Computing Breakthroughs in 2025", "url": "https://example.com"}]}}

// Claude's response with citations (omitted in this example)
```

## Batch requests

You can include the web search tool in the [Messages Batches API](/en/docs/build-with-claude/batch-processing). Web search tool calls through the Messages Batches API are priced the same as those in regular Messages API requests.

## Usage and pricing

Web search usage is charged in addition to token usage:

```json
"usage": {
  "input_tokens": 105,
  "output_tokens": 6039,
  "cache_read_input_tokens": 7123,
  "cache_creation_input_tokens": 7345,
  "server_tool_use": {
    "web_search_requests": 1
  }
}
```

Web search is available on the Anthropic API for \$10 per 1,000 searches, plus standard token costs for search-generated content. Web search results retrieved throughout a conversation are counted as input tokens, in search iterations executed during a single turn and in subsequent conversation turns.

Each web search counts as one use, regardless of the number of results returned. If an error occurs during web search, the web search will not be billed.


</tool.toolu_01H5cThGuZoCjGF7fjF3Uwm3>

## ASSISTANT:

Now I understand the issue better. Looking at the streaming data provided in the user's message, I can see that citations are delivered via `citations_delta` events. Let me analyze what needs to be implemented:

1. In the client streaming, there are content blocks with `citations: []` in `content_block_start`
2. Citations are populated via `citations_delta` events
3. Text blocks with citations shouldn't stream their text immediately - they should accumulate the citations first
4. When `content_block_stop` is reached for a citation block, it should be processed as a complete unit

Let me examine the streaming events more carefully and implement the citation support:

## TOOL USE:

Name: str-replace
ID: toolu_014NQpjiSUzucMzudqXgSzTx

### file-path

<tool.toolu_014NQpjiSUzucMzudqXgSzTx>
greger-client.el
</tool.toolu_014NQpjiSUzucMzudqXgSzTx>

### original-content

<tool.toolu_014NQpjiSUzucMzudqXgSzTx>
(defun greger-client--handle-content-block-start (data state)
  (let* ((index (alist-get 'index data))
         (content-block (copy-alist (alist-get 'content_block data)))
         (blocks (greger-client-state-content-blocks state))
         (type (alist-get 'type content-block)))

    ;; Initialize content for accumulation.
    ;; For tool_use and server_tool_use we make the input object a
    ;; string while we accumulate the output, and turn it back into
    ;; an object again in greger-client--handle-content-stop
    (cond
     ((string= type "tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
     ((string= type "server_tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
     ((string= type "text")
      (setf (alist-get 'text content-block) ""))

     ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Quantum Computing Breakthroughs in 2025","url":"https://example.com"}]}}
     ((string= type "web_search_tool_result")
      ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
      nil))

    (funcall (greger-client-state-block-start-callback state) type)

    ;; Add block at the right index
    (greger-client--ensure-block-at-index blocks index content-block state)))
</tool.toolu_014NQpjiSUzucMzudqXgSzTx>

### new-content

<tool.toolu_014NQpjiSUzucMzudqXgSzTx>
(defun greger-client--handle-content-block-start (data state)
  (let* ((index (alist-get 'index data))
         (content-block (copy-alist (alist-get 'content_block data)))
         (blocks (greger-client-state-content-blocks state))
         (type (alist-get 'type content-block))
         (citations (alist-get 'citations content-block)))

    ;; Initialize content for accumulation.
    ;; For tool_use and server_tool_use we make the input object a
    ;; string while we accumulate the output, and turn it back into
    ;; an object again in greger-client--handle-content-stop
    (cond
     ((string= type "tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
     ((string= type "server_tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
     ;; {"type":"content_block_start","index":3,"content_block":{"citations":[],"type":"text","text":""}}
     ((string= type "text")
      (setf (alist-get 'text content-block) "")
      ;; For text blocks with citations, initialize citations as empty list
      (when citations
        (setf (alist-get 'citations content-block) '())))

     ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Quantum Computing Breakthroughs in 2025","url":"https://example.com"}]}}
     ((string= type "web_search_tool_result")
      ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
      nil))

    (funcall (greger-client-state-block-start-callback state) type)

    ;; Add block at the right index
    (greger-client--ensure-block-at-index blocks index content-block state)))
</tool.toolu_014NQpjiSUzucMzudqXgSzTx>

### git-commit-message

<tool.toolu_014NQpjiSUzucMzudqXgSzTx>
Initialize citations list for text blocks in content_block_start
</tool.toolu_014NQpjiSUzucMzudqXgSzTx>

## TOOL RESULT:

ID: toolu_014NQpjiSUzucMzudqXgSzTx

<tool.toolu_014NQpjiSUzucMzudqXgSzTx>
Error executing tool: Original content not found in file: /Users/andreas/projects/greger.el/greger-client.el -- Try again!
</tool.toolu_014NQpjiSUzucMzudqXgSzTx>

## ASSISTANT:

Let me check the exact content first:

## TOOL USE:

Name: read-file
ID: toolu_01Ea2zRbYxn8gnBwT9E7oGQx

### path

<tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>
greger-client.el
</tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>

### start-line

<tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>
262
</tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>

### end-line

<tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>
293
</tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>

## TOOL RESULT:

ID: toolu_01Ea2zRbYxn8gnBwT9E7oGQx

<tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>
(defun greger-client--handle-content-block-start (data state)
  (let* ((index (alist-get 'index data))
         (content-block (copy-alist (alist-get 'content_block data)))
         (blocks (greger-client-state-content-blocks state))
         (type (alist-get 'type content-block)))

    ;; Initialize content for accumulation.
    ;; For tool_use and server_tool_use we make the input object a
    ;; string while we accumulate the output, and turn it back into
    ;; an object again in greger-client--handle-content-stop
    (cond
     ((string= type "tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
     ((string= type "server_tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
     ((string= type "text")
      (setf (alist-get 'text content-block) ""))

     ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Sweden Population (2025) - Worldometer","url":"https://www.worldometers.info/world-population/sweden-population/","encrypted_content":"Ev0P...YMYAw==","page_age":null}, [...] ]}}
     ((string= type "web_search_tool_result")
      ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
      nil))

    (funcall (greger-client-state-block-start-callback state) type)

    ;; Add block at the right index
    (greger-client--ensure-block-at-index blocks index content-block state)))

</tool.toolu_01Ea2zRbYxn8gnBwT9E7oGQx>

## TOOL USE:

Name: str-replace
ID: toolu_01VHRA3Lrjp6UrTD8GBNGfn7

### file-path

<tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>
greger-client.el
</tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>

### original-content

<tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>
(defun greger-client--handle-content-block-start (data state)
  (let* ((index (alist-get 'index data))
         (content-block (copy-alist (alist-get 'content_block data)))
         (blocks (greger-client-state-content-blocks state))
         (type (alist-get 'type content-block)))

    ;; Initialize content for accumulation.
    ;; For tool_use and server_tool_use we make the input object a
    ;; string while we accumulate the output, and turn it back into
    ;; an object again in greger-client--handle-content-stop
    (cond
     ((string= type "tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
     ((string= type "server_tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
     ((string= type "text")
      (setf (alist-get 'text content-block) ""))

     ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Sweden Population (2025) - Worldometer","url":"https://www.worldometers.info/world-population/sweden-population/","encrypted_content":"Ev0P...YMYAw==","page_age":null}, [...] ]}}
     ((string= type "web_search_tool_result")
      ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
      nil))

    (funcall (greger-client-state-block-start-callback state) type)

    ;; Add block at the right index
    (greger-client--ensure-block-at-index blocks index content-block state)))
</tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>

### new-content

<tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>
(defun greger-client--handle-content-block-start (data state)
  (let* ((index (alist-get 'index data))
         (content-block (copy-alist (alist-get 'content_block data)))
         (blocks (greger-client-state-content-blocks state))
         (type (alist-get 'type content-block))
         (citations (alist-get 'citations content-block)))

    ;; Initialize content for accumulation.
    ;; For tool_use and server_tool_use we make the input object a
    ;; string while we accumulate the output, and turn it back into
    ;; an object again in greger-client--handle-content-stop
    (cond
     ((string= type "tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":1,"content_block":{"type":"server_tool_use","id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","name":"web_search","input":{}}}
     ((string= type "server_tool_use")
      (setf (alist-get 'input content-block) ""))

     ;; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}
     ;; {"type":"content_block_start","index":3,"content_block":{"citations":[],"type":"text","text":""}}
     ((string= type "text")
      (setf (alist-get 'text content-block) "")
      ;; For text blocks with citations, initialize citations as empty list
      (when citations
        (setf (alist-get 'citations content-block) '())))

     ;; {"type":"content_block_start","index":2,"content_block":{"type":"web_search_tool_result","tool_use_id":"srvtoolu_01AZ1324bmQ29XW4fSECQJWH","content":[{"type":"web_search_result","title":"Sweden Population (2025) - Worldometer","url":"https://www.worldometers.info/world-population/sweden-population/","encrypted_content":"Ev0P...YMYAw==","page_age":null}, [...] ]}}
     ((string= type "web_search_tool_result")
      ;; No initialization needed - content is already present. No content_block_delta for web_search_tool_result
      nil))

    (funcall (greger-client-state-block-start-callback state) type)

    ;; Add block at the right index
    (greger-client--ensure-block-at-index blocks index content-block state)))
</tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>

### git-commit-message

<tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>
Initialize citations list for text blocks in content_block_start
</tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>

## TOOL RESULT:

ID: toolu_01VHRA3Lrjp6UrTD8GBNGfn7

<tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>
Successfully replaced content in /Users/andreas/projects/greger.el/greger-client.el. Successfully staged 2 file(s) and committed with message: Initialize citations list for text blocks in content_block_start
</tool.toolu_01VHRA3Lrjp6UrTD8GBNGfn7>

## ASSISTANT:

Now let me handle the `citations_delta` events in the content block delta function:

## TOOL USE:

Name: str-replace
ID: toolu_0124m7NuNRLiQfgb2QxviBCh

### file-path

<tool.toolu_0124m7NuNRLiQfgb2QxviBCh>
greger-client.el
</tool.toolu_0124m7NuNRLiQfgb2QxviBCh>

### original-content

<tool.toolu_0124m7NuNRLiQfgb2QxviBCh>
(defun greger-client--handle-content-block-delta (data state)
  (let* ((index (alist-get 'index data))
         (delta (alist-get 'delta data))
         (delta-type (alist-get 'type delta))
         (blocks (greger-client-state-content-blocks state))
         (block (nth index blocks)))

    ;; TODO: do we need to handle content block stop out-of-order,
    ;; before content-block start has created the block in the state's content-blocks?

    (cond

     ;; assistant text and thinking
     ;; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"I'll search for the"}}
     ((string= delta-type "text_delta")
      (let ((text (alist-get 'text delta)))
        (setf (alist-get 'text block)
              (concat (alist-get 'text block) text))
        ;; Call text callback for live display
        (funcall (greger-client-state-text-delta-callback state) text)))

     ;; tool_use and server_tool_use
     ;; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":""}}
     ((string= delta-type "input_json_delta")
      (let ((partial-json (alist-get 'partial_json delta)))
        (setf (alist-get 'input block)
              (concat (alist-get 'input block) partial-json)))))))
</tool.toolu_0124m7NuNRLiQfgb2QxviBCh>

### new-content

<tool.toolu_0124m7NuNRLiQfgb2QxviBCh>
(defun greger-client--handle-content-block-delta (data state)
  (let* ((index (alist-get 'index data))
         (delta (alist-get 'delta data))
         (delta-type (alist-get 'type delta))
         (blocks (greger-client-state-content-blocks state))
         (block (nth index blocks)))

    ;; TODO: do we need to handle content block stop out-of-order,
    ;; before content-block start has created the block in the state's content-blocks?

    (cond

     ;; assistant text and thinking
     ;; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"I'll search for the"}}
     ((string= delta-type "text_delta")
      (let ((text (alist-get 'text delta))
            (has-citations (alist-get 'citations block)))
        (setf (alist-get 'text block)
              (concat (alist-get 'text block) text))
        ;; Only call text callback for live display if this block doesn't have citations
        ;; Citation blocks should not stream text - they'll be handled in block-stop
        (unless has-citations
          (funcall (greger-client-state-text-delta-callback state) text))))

     ;; tool_use and server_tool_use
     ;; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":""}}
     ((string= delta-type "input_json_delta")
      (let ((partial-json (alist-get 'partial_json delta)))
        (setf (alist-get 'input block)
              (concat (alist-get 'input block) partial-json))))

     ;; Citations accumulation
     ;; {"type":"content_block_delta","index":3,"delta":{"type":"citations_delta","citation":{"type":"web_search_result_location",...}}}
     ((string= delta-type "citations_delta")
      (let ((citation (alist-get 'citation delta))
            (current-citations (alist-get 'citations block)))
        ;; Add the new citation to the list
        (setf (alist-get 'citations block)
              (append current-citations (list citation))))))))
</tool.toolu_0124m7NuNRLiQfgb2QxviBCh>

### git-commit-message

<tool.toolu_0124m7NuNRLiQfgb2QxviBCh>
Handle citations_delta events and suppress text streaming for citation blocks
</tool.toolu_0124m7NuNRLiQfgb2QxviBCh>

<!-- TOOL_RESULT_PLACEHOLDER_toolu_0124m7NuNRLiQfgb2QxviBCh -->