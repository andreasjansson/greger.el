{
  "tool_choice": {
    "type": "auto"
  },
  "tools": [
    {
      "name": "read-file",
      "description": "Read the contents of a file from the filesystem",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the file to read"
          },
          "include_line_numbers": {
            "type": "boolean",
            "description": "Whether to include line numbers in the output. If you plan to modify the file, you should include line numbers here so you know which lines to edit.",
            "default": null
          },
          "start_line": {
            "type": "integer",
            "description": "Starting line number (1-based) to begin reading from. If not specified, reads from the beginning of the file.",
            "default": null
          },
          "end_line": {
            "type": "integer",
            "description": "Ending line number (1-based) to stop reading at (inclusive). If not specified, reads to the end of the file.",
            "default": null
          }
        },
        "required": [
          "path"
        ]
      }
    },
    {
      "name": "list-directory",
      "description": "List files and directories in a given directory",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the directory to list. Defaults to current directory.",
            "default": "."
          },
          "show-hidden": {
            "type": "boolean",
            "description": "Whether to show hidden files starting with .",
            "default": null
          },
          "recursive": {
            "type": "boolean",
            "description": "Whether to list files recursively",
            "default": null
          }
        },
        "required": null
      }
    },
    {
      "name": "str-replace",
      "description": "Replace a specific string or content block in a file with new content. Finds the exact original content and replaces it with new content. Be extra careful to format the original_content exactly correctly, taking extra care with whitespace and newlines. If you're making large swaths of changes, consider using replace-file instead",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Path to the file to modify"
          },
          "original_content": {
            "type": "string",
            "description": "The exact content to find and replace"
          },
          "new_content": {
            "type": "string",
            "description": "The new content to replace the original content with"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "file_path",
          "original_content",
          "new_content",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "insert",
      "description": "Insert text at a specific line number in a file. The text will be inserted before the specified line number (use 0 to insert at the beginning of the file, 1 to insert before the first line, etc.). Useful for adding new content, comments, or code blocks at precise locations without replacing existing content.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Path to the file to modify"
          },
          "line_number": {
            "type": "integer",
            "description": "Line number before which to insert the content (0 for beginning of file, 1 to insert before first line, etc.)"
          },
          "content": {
            "type": "string",
            "description": "Content to insert at the specified location"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "file_path",
          "line_number",
          "content",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "write-new-file",
      "description": "Write a new file with the given contents. Fails if the file already exists.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Absolute path to the new file"
          },
          "contents": {
            "type": "string",
            "description": "Contents to write to the new file"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "file_path",
          "contents",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "replace-file",
      "description": "Replace the entire contents of an existing file. Slow but reliable - replaces the complete file contents. Use str-replace for specific changes in large files, or replace-function for Python/Elisp functions.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Path to the file to replace"
          },
          "contents": {
            "type": "string",
            "description": "New contents to replace the entire file"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "file_path",
          "contents",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "replace-function",
      "description": "Replace a function in a Python or Elisp file with new contents. Fast and reliable - only supports 'def function_name' and '(defun function_name ())' forms. Use replace-file for complete file replacement or str-replace for other specific changes.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Path to the file containing the function"
          },
          "function_name": {
            "type": "string",
            "description": "Name of the function to replace"
          },
          "contents": {
            "type": "string",
            "description": "New function contents to replace the existing function"
          },
          "line_number": {
            "type": "integer",
            "description": "Line number where the function is defined"
          },
          "commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "file_path",
          "function_name",
          "contents",
          "line_number",
          "commit_message"
        ]
      }
    },
    {
      "name": "make-directory",
      "description": "Recursively create a directory and all parent directories if they don't exist",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the directory to create"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "path",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "rename-file",
      "description": "Rename or move a file from one path to another",
      "input_schema": {
        "type": "object",
        "properties": {
          "old_path": {
            "type": "string",
            "description": "Current path of the file"
          },
          "new_path": {
            "type": "string",
            "description": "New path for the file"
          },
          "git_commit_message": {
            "type": "string",
            "description": "Git commit message for this change"
          }
        },
        "required": [
          "old_path",
          "new_path",
          "git_commit_message"
        ]
      }
    },
    {
      "name": "ripgrep",
      "description": "Search for patterns in files using ripgrep (rg) command line tool. Note that ripgrep only matches on single lines, so you can't search across multiple lines.",
      "input_schema": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "The search pattern (regex or literal string)"
          },
          "path": {
            "type": "string",
            "description": "Directory or file path to search in",
            "default": "."
          },
          "case-sensitive": {
            "type": "boolean",
            "description": "Whether the search should be case-sensitive",
            "default": null
          },
          "file-type": {
            "type": "string",
            "description": "Restrict search to specific file types (e.g., 'py', 'js', 'md')"
          },
          "context-lines": {
            "type": "integer",
            "description": "Number of context lines to show around matches",
            "default": 0
          },
          "max-results": {
            "type": "integer",
            "description": "Maximum number of results to return",
            "default": 50
          }
        },
        "required": [
          "pattern"
        ]
      }
    },
    {
      "name": "git-log",
      "description": "View git commit logs.",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the git repository or any file in the repository view logs for",
            "default": "."
          },
          "max_rows": {
            "type": "integer",
            "description": "Maximum number of log entries to return",
            "default": 100
          }
        },
        "required": null
      }
    },
    {
      "name": "git-show-commit",
      "description": "View a specific git commit.",
      "input_schema": {
        "type": "object",
        "properties": {
          "commit_hash": {
            "type": "string",
            "description": "The commit hash to view"
          },
          "path": {
            "type": "string",
            "description": "Path to the git repository or any file in the repository",
            "default": "."
          }
        },
        "required": [
          "commit_hash"
        ]
      }
    },
    {
      "name": "shell-command",
      "description": "Execute an arbitrary shell command and return the output. Prompts for permission before running the command for security.",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The shell command to execute"
          },
          "working_directory": {
            "type": "string",
            "description": "Directory to run the command in",
            "default": "."
          }
        },
        "required": [
          "command"
        ]
      }
    },
    {
      "name": "read-webpage",
      "description": "Read webpage content from a URL. Can return either extracted text or raw HTML.",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "The URL to read content from"
          },
          "extract_text": {
            "type": "boolean",
            "description": "Whether to extract text content or return raw HTML",
            "default": true
          },
          "use_highest_readability": {
            "type": "boolean",
            "description": "Whether to use eww's aggressive highest readability setting for better text extraction",
            "default": null
          }
        },
        "required": [
          "url"
        ]
      }
    }
  ],
  "model": "claude-sonnet-4-20250514",
  "messages": [
    {
      "role": "user",
      "content": "Update test-greger-agent.el more readable by each test having an \"expected\" input to compare to the actual buffer-content after executing the tools, using string=."
    },
    {
      "role": "assistant",
      "content": [
        {
          "type": "text",
          "text": "I'll first examine the current test file to understand its structure and then update it to make it more readable with explicit expected inputs."
        },
        {
          "type": "tool_use",
          "id": "toolu_01A1ZsJMedxPjnEBb7oUU1ph",
          "name": "read-file",
          "input": {
            "path": "test-greger-agent.el",
            "include_line_numbers": true
          }
        }
      ]
    },
    {
      "role": "user",
      "content": [
        {
          "cache_control": {
            "type": "ephemeral"
          },
          "type": "tool_result",
          "tool_use_id": "toolu_01A1ZsJMedxPjnEBb7oUU1ph",
          "content": "1: ;;; test-greger-agent.el --- Tests for greger agent functionality -*- lexical-binding: t -*-\n  2: \n  3: (require 'ert)\n  4: (require 'greger-agent)\n  5: (require 'greger-tools)\n  6: (require 'greger-parser)\n  7: \n  8: (ert-deftest greger-agent-test-tool-placeholder ()\n  9:   \"Test the tool placeholder helper function.\"\n 10:   (should (string= \"<!-- TOOL_RESULT_PLACEHOLDER_test123 -->\"\n 11:                    (greger-agent--tool-placeholder \"test123\")))\n 12:   (should (string= \"<!-- TOOL_RESULT_PLACEHOLDER_tool_abc_def -->\"\n 13:                    (greger-agent--tool-placeholder \"tool_abc_def\"))))\n 14: \n 15: (ert-deftest greger-agent-test-single-tool-execution ()\n 16:   \"Test execution of a single tool with callback.\"\n 17:   (let ((test-completed nil)\n 18:         (test-result nil)\n 19:         (test-error nil))\n 20: \n 21:     ;; Define a simple test function\n 22:     (defun greger-test-simple-tool (message)\n 23:       (format \"Tool executed: %s\" message))\n 24: \n 25:     ;; Register test tool\n 26:     (greger-register-tool \"test-simple\"\n 27:       :description \"Simple test tool\"\n 28:       :properties '((message . ((type . \"string\")\n 29:                                 (description . \"Test message\"))))\n 30:       :required '(\"message\")\n 31:       :function 'greger-test-simple-tool)\n 32: \n 33:     ;; Create test buffer\n 34:     (with-temp-buffer\n 35:       (let ((agent-state (make-greger-agent-state\n 36:                           :current-iteration 0\n 37:                           :chat-buffer (current-buffer)\n 38:                           :directory default-directory))\n 39:             (tool-calls `(((type . \"tool_use\")\n 40:                           (id . \"test_001\")\n 41:                           (name . \"test-simple\")\n 42:                           (input . ((message . \"Hello World\")))))))\n 43: \n 44:         ;; Mock greger-agent--run-agent-loop to capture completion\n 45:         (cl-letf (((symbol-function 'greger-agent--run-agent-loop)\n 46:                    (lambda (state)\n 47:                      (setq test-completed t))))\n 48: \n 49:           ;; Execute tools\n 50:           (greger-agent--execute-tools tool-calls agent-state)\n 51: \n 52:           ;; Check that the function completed\n 53:           (should test-completed)\n 54: \n 55:           ;; Check buffer contents\n 56:           (let ((buffer-content (buffer-substring-no-properties (point-min) (point-max))))\n 57:             (should (string-match-p \"test-simple\" buffer-content))\n 58:             (should (string-match-p \"Tool executed: Hello World\" buffer-content))))))\n 59: \n 60:     ;; Clean up\n 61:     (remhash \"test-simple\" greger-tools-registry)))\n 62: \n 63: (ert-deftest greger-agent-test-multiple-tools-parallel ()\n 64:   \"Test execution of multiple tools in parallel.\"\n 65:   (let ((completion-count 0)\n 66:         (tools-completed nil))\n 67: \n 68:     ;; Define test functions with different execution times\n 69:     (defun greger-test-tool-a (value)\n 70:       (format \"Tool A result: %s\" value))\n 71: \n 72:     (defun greger-test-tool-b (value)\n 73:       (format \"Tool B result: %s\" value))\n 74: \n 75:     ;; Register test tools\n 76:     (greger-register-tool \"test-tool-a\"\n 77:       :description \"Test tool A\"\n 78:       :properties '((value . ((type . \"string\")\n 79:                               (description . \"Input value\"))))\n 80:       :required '(\"value\")\n 81:       :function 'greger-test-tool-a)\n 82: \n 83:     (greger-register-tool \"test-tool-b\"\n 84:       :description \"Test tool B\"\n 85:       :properties '((value . ((type . \"string\")\n 86:                               (description . \"Input value\"))))\n 87:       :required '(\"value\")\n 88:       :function 'greger-test-tool-b)\n 89: \n 90:     ;; Create test buffer\n 91:     (with-temp-buffer\n 92:       (let ((agent-state (make-greger-agent-state\n 93:                           :current-iteration 0\n 94:                           :chat-buffer (current-buffer)\n 95:                           :directory default-directory))\n 96:             (tool-calls `(((type . \"tool_use\")\n 97:                           (id . \"test_a\")\n 98:                           (name . \"test-tool-a\")\n 99:                           (input . ((value . \"input-a\"))))\n100:                          ((type . \"tool_use\")\n101:                           (id . \"test_b\")\n102:                           (name . \"test-tool-b\")\n103:                           (input . ((value . \"input-b\")))))))\n104: \n105:         ;; Mock greger-agent--run-agent-loop to capture completion\n106:         (cl-letf (((symbol-function 'greger-agent--run-agent-loop)\n107:                    (lambda (state)\n108:                      (setq tools-completed t))))\n109: \n110:           ;; Execute tools\n111:           (greger-agent--execute-tools tool-calls agent-state)\n112: \n113:           ;; Check that all tools completed\n114:           (should tools-completed)\n115: \n116:           ;; Check buffer contents - both tools should have executed\n117:           (let ((buffer-content (buffer-substring-no-properties (point-min) (point-max))))\n118:             (should (string-match-p \"Tool A result: input-a\" buffer-content))\n119:             (should (string-match-p \"Tool B result: input-b\" buffer-content))\n120:             (should (string-match-p \"test-tool-a\" buffer-content))\n121:             (should (string-match-p \"test-tool-b\" buffer-content))))))\n122: \n123:     ;; Clean up\n124:     (remhash \"test-tool-a\" greger-tools-registry)\n125:     (remhash \"test-tool-b\" greger-tools-registry)))\n126: \n127: (ert-deftest greger-agent-test-tool-error-handling ()\n128:   \"Test that tool errors are properly handled and displayed.\"\n129:   (let ((test-completed nil))\n130: \n131:     ;; Define a tool function that throws an error\n132:     (defun greger-test-error-tool (input)\n133:       (error \"Simulated tool error: %s\" input))\n134: \n135:     ;; Register test tool\n136:     (greger-register-tool \"test-error\"\n137:       :description \"Tool that throws an error\"\n138:       :properties '((input . ((type . \"string\")\n139:                               (description . \"Input that will cause error\"))))\n140:       :required '(\"input\")\n141:       :function 'greger-test-error-tool)\n142: \n143:     ;; Create test buffer\n144:     (with-temp-buffer\n145:       (let ((agent-state (make-greger-agent-state\n146:                           :current-iteration 0\n147:                           :chat-buffer (current-buffer)\n148:                           :directory default-directory))\n149:             (tool-calls `(((type . \"tool_use\")\n150:                           (id . \"error_test\")\n151:                           (name . \"test-error\")\n152:                           (input . ((input . \"bad-input\")))))))\n153: \n154:         ;; Mock greger-agent--run-agent-loop to capture completion\n155:         (cl-letf (((symbol-function 'greger-agent--run-agent-loop)\n156:                    (lambda (state)\n157:                      (setq test-completed t))))\n158: \n159:           ;; Execute tools\n160:           (greger-agent--execute-tools tool-calls agent-state)\n161: \n162:           ;; Check that execution completed despite error\n163:           (should test-completed)\n164: \n165:           ;; Check buffer contents - error should be displayed\n166:           (let ((buffer-content (buffer-substring-no-properties (point-min) (point-max))))\n167:             (should (string-match-p \"Error executing tool\" buffer-content))\n168:             (should (string-match-p \"Simulated tool error\" buffer-content))\n169:             (should (string-match-p \"bad-input\" buffer-content))))))\n170: \n171:     ;; Clean up\n172:     (remhash \"test-error\" greger-tools-registry)))\n173: \n174: (ert-deftest greger-agent-test-placeholder-replacement ()\n175:   \"Test that placeholders are correctly replaced with tool results.\"\n176:   (let ((test-completed nil))\n177: \n178:     ;; Define a simple test function\n179:     (defun greger-test-placeholder-tool (data)\n180:       (format \"Processed: %s\" data))\n181: \n182:     ;; Register test tool\n183:     (greger-register-tool \"test-placeholder\"\n184:       :description \"Test placeholder replacement\"\n185:       :properties '((data . ((type . \"string\")\n186:                              (description . \"Data to process\"))))\n187:       :required '(\"data\")\n188:       :function 'greger-test-placeholder-tool)\n189: \n190:     ;; Create test buffer\n191:     (with-temp-buffer\n192:       (let ((agent-state (make-greger-agent-state\n193:                           :current-iteration 0\n194:                           :chat-buffer (current-buffer)\n195:                           :directory default-directory))\n196:             (tool-calls `(((type . \"tool_use\")\n197:                           (id . \"placeholder_test\")\n198:                           (name . \"test-placeholder\")\n199:                           (input . ((data . \"test-data\")))))))\n200: \n201:         ;; Mock greger-agent--run-agent-loop to capture completion\n202:         (cl-letf (((symbol-function 'greger-agent--run-agent-loop)\n203:                    (lambda (state)\n204:                      (setq test-completed t))))\n205: \n206:           ;; Execute tools\n207:           (greger-agent--execute-tools tool-calls agent-state)\n208: \n209:           ;; Check that execution completed\n210:           (should test-completed)\n211: \n212:           ;; Check that placeholder was replaced\n213:           (let ((buffer-content (buffer-substring-no-properties (point-min) (point-max))))\n214:             ;; Placeholder should not exist anymore\n215:             (should-not (string-match-p \"TOOL_RESULT_PLACEHOLDER_placeholder_test\" buffer-content))\n216:             ;; Result should be present\n217:             (should (string-match-p \"Processed: test-data\" buffer-content))))))\n218: \n219:     ;; Clean up\n220:     (remhash \"test-placeholder\" greger-tools-registry)))\n221: \n222: (ert-deftest greger-agent-test-unknown-tool-error ()\n223:   \"Test handling of unknown tool execution.\"\n224:   (let ((test-completed nil))\n225: \n226:     ;; Create test buffer\n227:     (with-temp-buffer\n228:       (let ((agent-state (make-greger-agent-state\n229:                           :current-iteration 0\n230:                           :chat-buffer (current-buffer)\n231:                           :directory default-directory))\n232:             (tool-calls `(((type . \"tool_use\")\n233:                           (id . \"unknown_test\")\n234:                           (name . \"nonexistent-tool\")\n235:                           (input . ((param . \"value\")))))))\n236: \n237:         ;; Mock greger-agent--run-agent-loop to capture completion\n238:         (cl-letf (((symbol-function 'greger-agent--run-agent-loop)\n239:                    (lambda (state)\n240:                      (setq test-completed t))))\n241: \n242:           ;; Execute tools\n243:           (greger-agent--execute-tools tool-calls agent-state)\n244: \n245:           ;; Check that execution completed despite unknown tool\n246:           (should test-completed)\n247: \n248:           ;; Check buffer contents - error should be displayed\n249:           (let ((buffer-content (buffer-substring-no-properties (point-min) (point-max))))\n250:             (should (string-match-p \"Unknown tool: nonexistent-tool\" buffer-content))))))))\n251: \n252: (provide 'test-greger-agent)\n253: \n254: ;;; test-greger-agent.el ends here\n255: "
        }
      ]
    },
    {
      "role": "assistant",
      "content": "Now I'll update the test file to make it more readable by adding explicit expected content for each test and using `string=` for comparisons. I'll refactor each test to have clear expected output that can be compared against the actual buffer content."
    }
  ],
  "max_tokens": 8192,
  "stream": true
}