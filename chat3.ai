## SYSTEM:

## USER:

In greger-stream.el greger-stream--process-output-chunk, raise an error if output is an error.

This is what an error output looks like

``` json
{"type":"error","error":{"type":"invalid_request_error","message":"input length and ‘max_tokens‘ exceed context limit: 142200 + 64000 > 200000, decrease input length or ‘max_tokens‘ and try again"}}
```

## ASSISTANT:

I'll help you modify the `greger-stream--process-output-chunk` function to raise an error when the output indicates an error. First, let me examine the current file structure and find the function.

## TOOL USE:

Name: list-directory
ID: toolu_01XHMxpcyqH9XH1jEJ8nD1J5

### path

<tool.toolu_01XHMxpcyqH9XH1jEJ8nD1J5>
.
</tool.toolu_01XHMxpcyqH9XH1jEJ8nD1J5>

## TOOL RESULT:

ID: toolu_01XHMxpcyqH9XH1jEJ8nD1J5

<tool.toolu_01XHMxpcyqH9XH1jEJ8nD1J5>
chat.ai
chat2.ai
chat3.ai
chat4.ai
chat5.ai
debug-test.el
greger-agent.el
greger-lib-lsp.el
greger-parser.el
greger-provider-claude.el
greger-provider-google.el
greger-provider-openai.el
greger-providers.el
greger-stdlib.el
greger-stream.el
greger-tools.el
greger-web.el
greger.el
request.json
test-greger-agent.el
test-greger-lib-lsp.el
test-greger-parser.el
test-greger-stdlib.el
test-greger-tools.el
</tool.toolu_01XHMxpcyqH9XH1jEJ8nD1J5>

## TOOL USE:

Name: read-file
ID: toolu_016uzSKqJgp74uLfR8anQJp3

### path

<tool.toolu_016uzSKqJgp74uLfR8anQJp3>
greger-stream.el
</tool.toolu_016uzSKqJgp74uLfR8anQJp3>

## TOOL RESULT:

ID: toolu_016uzSKqJgp74uLfR8anQJp3

<tool.toolu_016uzSKqJgp74uLfR8anQJp3>
;;; greger-stream.el --- Streaming support for greger -*- lexical-binding: t -*-

;;; Commentary:
;; Handles streaming responses from AI providers

;;; Code:

(require 'json)
(require 'cl-lib)
(require 'greger-providers)
(require 'greger)

;;; Data structures

(cl-defstruct greger-stream-state
  accumulated-output
  complete-response
  parsed-content-blocks
  process
  output-buffer
  undo-handle
  original-quit-binding
  text-start-callback
  text-callback
  complete-callback
  cancel-callback
  restore-callback)

;;; Public API

(cl-defun greger-stream-to-buffer (&key model dialog buffer text-start-callback text-callback complete-callback cancel-callback)
  "Send streaming request for MODEL with DIALOG, inserting text into BUFFER.
TEXT-START-CALLBACK is called when text streaming starts.
TEXT-CALLBACK is called for each text chunk with (state text).
COMPLETE-CALLBACK is called when done with the parsed content blocks array.
CANCEL-CALLBACK is called if cancelled.
BUFFER defaults to current buffer if not specified."
  (greger-stream-to-buffer-with-tools
   :model model
   :dialog dialog
   :tools nil
   :buffer buffer
   :text-start-callback text-start-callback
   :text-callback text-callback
   :complete-callback complete-callback
   :cancel-callback cancel-callback))

(cl-defun greger-stream-to-buffer-with-tools (&key model dialog tools buffer text-start-callback text-callback complete-callback cancel-callback)
  "Send streaming request for MODEL with DIALOG and TOOLS, inserting text into BUFFER.
TEXT-START-CALLBACK is called when text streaming starts.
TEXT-CALLBACK is called for each text chunk with (text).
COMPLETE-CALLBACK is called when done with the parsed content blocks array.
CANCEL-CALLBACK is called if cancelled.
BUFFER defaults to current buffer if not specified."
  (let* ((output-buffer (or buffer (current-buffer)))
         (undo-handle (prepare-change-group output-buffer))
         (original-quit-binding (local-key-binding (kbd "C-g")))
         (provider-config (greger-providers-get-config model))
         (request-spec (greger-providers-build-request provider-config dialog tools))
         (restore-callback (lambda (state)
                             (with-current-buffer (greger-stream-state-output-buffer state)
                               (local-set-key (kbd "C-g")
                                              (greger-stream-state-original-quit-binding state))
                               (undo-amalgamate-change-group (greger-stream-state-undo-handle state))
                               (accept-change-group (greger-stream-state-undo-handle state)))))
         (wrapped-complete-callback (lambda (parsed-blocks state)
                                      (when complete-callback
                                        (funcall complete-callback parsed-blocks))))
         (process (greger-stream--start-curl-process request-spec))
         (state (make-greger-stream-state
                 :accumulated-output ""
                 :complete-response ""
                 :parsed-content-blocks '()
                 :process process
                 :text-start-callback text-start-callback
                 :text-callback text-callback
                 :complete-callback wrapped-complete-callback
                 :cancel-callback cancel-callback
                 :restore-callback restore-callback
                 :output-buffer output-buffer
                 :undo-handle undo-handle
                 :original-quit-binding original-quit-binding)))

    (activate-change-group undo-handle)

    (set-process-filter process
                       (lambda (proc output)
                         (declare (ignore proc))
                         (greger-stream--process-output-chunk output state provider-config)))

    (set-process-sentinel process
                         (lambda (proc event)
                           (declare (ignore event))
                           (greger-stream--handle-completion proc state provider-config)))

    (set-process-query-on-exit-flag process nil)

    (greger-stream--setup-cancel-binding state)

    state))




;;; Internal implementation

(defun greger-stream--setup-cancel-binding (state)
  "Setup C-g binding for cancellation in the output buffer."
  (with-current-buffer (greger-stream-state-output-buffer state)
    (local-set-key (kbd "C-g")
                   (lambda ()
                     (interactive)
                     (greger-stream--cancel-request state)))))

(defun greger-stream--process-output-chunk (output state provider-config)
  "Process a chunk of OUTPUT using STATE."
  ;; Always accumulate for complete response

  ;; TODO: handle errors of the format
  ;; output={"type":"error","error":{"type":"invalid_request_error","message":"tools.0.custom.input_schema: Input does not match the expected shape."}}
  ;(message (format "output: %s" output))

  (setf (greger-stream-state-complete-response state)
        (concat (greger-stream-state-complete-response state) output))

  ;; Update working buffer for chunk processing
  (setf (greger-stream-state-accumulated-output state)
        (concat (greger-stream-state-accumulated-output state) output))

  (greger-stream--process-claude-events state))

(defun greger-stream--process-claude-events (state)
  "Process Claude streaming events from accumulated output in STATE."
  (let ((accumulated (greger-stream-state-accumulated-output state))
        (remaining ""))

    ;; Process complete lines (events)
    (while (string-match "\n" accumulated)
      (let* ((line-end (match-end 0))
             (line (substring accumulated 0 (1- line-end))))

        ;; Process the line if it's a data event
        (when (string-prefix-p "data: " line)
          (let ((data-json (substring line 6)))
            (unless (string= data-json "[DONE]")
              (greger-stream--handle-claude-event data-json state))))

        ;; Remove processed line
        (setq accumulated (substring accumulated line-end))))

    ;; Store remaining incomplete data
    (setf (greger-stream-state-accumulated-output state) accumulated)))

(defun greger-stream--handle-claude-event (data-json state)
; Example of incoming data json (one data-json per line)
; {"type":"message_start","message":{"id":"msg_01Qm7bzEMGbdRyAuF5Lrb1Tg","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2626,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":1,"service_tier":"standard"}}     }
; {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}        }
; {"type": "ping"}
; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"I"}           }
; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"'ll first read the existing file to see what's already there,"}            }
; {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":" then add a new function in the same style."}    }
; {"type":"content_block_stop","index":0        }
; {"type":"content_block_start","index":1,"content_block":{"type":"tool_use","id":"toolu_01NmTNDZcJdGAMsrWQy1Heff","name":"read-file","input":{}}        }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":""}           }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"{\""}   }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"path\": \"~/s"}        }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"cratch/aicha"}   }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"t/hel"}     }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"lo."}            }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"py\""} }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":", \"includ"}     }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"e_li"}        }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"ne_numb"}       }
; {"type":"content_block_delta","index":1,"delta":{"type":"input_json_delta","partial_json":"ers\": true}"}            }
; {"type":"content_block_stop","index":1            }
; {"type":"message_delta","delta":{"stop_reason":"tool_use","stop_sequence":null},"usage":{"output_tokens":108}        }
; {"type":"message_stop"    }

  ;(greger-agent--debug "INCOMING data-json %s" data-json)
  (let* ((data (json-read-from-string data-json))
         (type (alist-get 'type data)))
    (cond
     ;; Content block start - create new content block
     ((string= type "content_block_start")
      (let* ((index (alist-get 'index data))
             (content-block (copy-alist (alist-get 'content_block data)))
             (blocks (greger-stream-state-parsed-content-blocks state)))

        ;; Initialize content for accumulation
        ;; TODO: is this necessary?
        (cond
         ((string= (alist-get 'type content-block) "tool_use")
          (setf (alist-get 'input content-block) ""))
         ((string= (alist-get 'type content-block) "text")
          (setf (alist-get 'text content-block) "")))

        (when (and (string= (alist-get 'type content-block) "text")
                   (greger-stream-state-text-start-callback state))
          (funcall (greger-stream-state-text-start-callback state)))

        ;; Add block at the right index
        (greger-stream--ensure-block-at-index blocks index content-block state)))

     ;; Content block delta - update existing content block
     ((string= type "content_block_delta")
      (let* ((index (alist-get 'index data))
             (delta (alist-get 'delta data))
             (delta-type (alist-get 'type delta))
             (blocks (greger-stream-state-parsed-content-blocks state)))

        (when (< index (length blocks))
          (let ((block (nth index blocks)))
            (cond
             ;; Text delta
             ((string= delta-type "text_delta")
              (let ((text (alist-get 'text delta)))
                (setf (alist-get 'text block)
                      (concat (alist-get 'text block) text))
                ;; Call text callback for live display
                (when (greger-stream-state-text-callback state)
                  (funcall (greger-stream-state-text-callback state) text))))

             ;; Tool input delta
             ((string= delta-type "input_json_delta")
              (let ((partial-json (alist-get 'partial_json delta)))
                (setf (alist-get 'input block)
                      (concat (alist-get 'input block) partial-json)))))))))

     ;; Content block stop - finalize tool input if needed
     ((string= type "content_block_stop")
      (let* ((index (alist-get 'index data))
             (blocks (greger-stream-state-parsed-content-blocks state)))

        (when (< index (length blocks))
          (let ((block (nth index blocks)))
            (when (and (string= (alist-get 'type block) "tool_use")
                       (stringp (alist-get 'input block)))
              ;; Parse accumulated JSON input
              (let ((input-str (alist-get 'input block)))
                (condition-case nil
                    (if (string-empty-p input-str)
                        (setf (alist-get 'input block) '())
                      (setf (alist-get 'input block)
                            (json-read-from-string input-str)))
                  (error
                   (setf (alist-get 'input block) '()))))))))))))

(defun greger-stream--ensure-block-at-index (blocks index new-block state)
  "Ensure BLOCKS list has NEW-BLOCK at INDEX, extending if necessary."
  (let ((current-blocks (greger-stream-state-parsed-content-blocks state)))
    ;; Extend list if needed
    (while (<= (length current-blocks) index)
      (setq current-blocks (append current-blocks (list nil))))

    ;; Set the block at index
    (setf (nth index current-blocks) new-block)
    (setf (greger-stream-state-parsed-content-blocks state) current-blocks)))

(defun greger-stream--handle-completion (proc state provider-config)
  "Handle process completion for PROC using STATE."
  (when (memq (process-status proc) '(exit signal))
    (funcall (greger-stream-state-restore-callback state) state)

    (if (= (process-exit-status proc) 0)
        (when (greger-stream-state-complete-callback state)
          (let ((parsed-blocks (greger-stream-state-parsed-content-blocks state)))
            (funcall (greger-stream-state-complete-callback state) parsed-blocks state)))
      (when (greger-stream-state-cancel-callback state)
        (funcall (greger-stream-state-cancel-callback state))))))

(defun greger-stream--cancel-request (state)
  "Cancel streaming request using STATE."
  (let ((process (greger-stream-state-process state)))
    (when (process-live-p process)
      (message "Interrupting generation")
      (interrupt-process process)
      (sit-for 0.1)
      (delete-process process)
      (when (greger-stream-state-cancel-callback state)
        (funcall (greger-stream-state-cancel-callback state))))
    (funcall (greger-stream-state-restore-callback state) state)))

;;; Utility functions

(defun greger-stream--start-curl-process (request-spec)
  "Start curl process with REQUEST-SPEC."
  (start-process-shell-command
   "greger-curl" nil
   (greger-stream--build-curl-command request-spec)))

(defun greger-stream--build-curl-command (request-spec)
  "Build curl command from REQUEST-SPEC."
  (let ((url (plist-get request-spec :url))
        (method (plist-get request-spec :method))
        (headers (plist-get request-spec :headers))
        (data (plist-get request-spec :data)))
    (format "curl -s -X %s %s %s %s"
            method
            (mapconcat (lambda (header)
                         (format "-H \"%s: %s\"" (car header) (cdr header)))
                       headers " ")
            (if data
                (format "--data-raw %s" (shell-quote-argument data))
              "")
            url)))

(provide 'greger-stream)

;;; greger-stream.el ends here

</tool.toolu_016uzSKqJgp74uLfR8anQJp3>

## ASSISTANT:

Now I can see the `greger-stream--process-output-chunk` function. I need to modify it to check if the output contains an error and raise an error accordingly. Let me examine the function more closely and implement the error handling:

## TOOL USE:

Name: str-replace
ID: toolu_013wNA7urSdfecLSxvgruB1U

### file_path

<tool.toolu_013wNA7urSdfecLSxvgruB1U>
greger-stream.el
</tool.toolu_013wNA7urSdfecLSxvgruB1U>

### original_content

<tool.toolu_013wNA7urSdfecLSxvgruB1U>
(defun greger-stream--process-output-chunk (output state provider-config)
  "Process a chunk of OUTPUT using STATE."
  ;; Always accumulate for complete response

  ;; TODO: handle errors of the format
  ;; output={"type":"error","error":{"type":"invalid_request_error","message":"tools.0.custom.input_schema: Input does not match the expected shape."}}
  ;(message (format "output: %s" output))

  (setf (greger-stream-state-complete-response state)
        (concat (greger-stream-state-complete-response state) output))

  ;; Update working buffer for chunk processing
  (setf (greger-stream-state-accumulated-output state)
        (concat (greger-stream-state-accumulated-output state) output))

  (greger-stream--process-claude-events state))
</tool.toolu_013wNA7urSdfecLSxvgruB1U>

### new_content

<tool.toolu_013wNA7urSdfecLSxvgruB1U>
(defun greger-stream--process-output-chunk (output state provider-config)
  "Process a chunk of OUTPUT using STATE."
  ;; Always accumulate for complete response

  ;; Check for error responses and raise an error if found
  (when (string-match-p "^{\"type\":\"error\"" output)
    (condition-case nil
        (let* ((error-data (json-read-from-string output))
               (error-info (alist-get 'error error-data))
               (error-message (alist-get 'message error-info))
               (error-type (alist-get 'type error-info)))
          (error "API Error (%s): %s" error-type error-message))
      (json-error
       (error "API Error: %s" output))))

  (setf (greger-stream-state-complete-response state)
        (concat (greger-stream-state-complete-response state) output))

  ;; Update working buffer for chunk processing
  (setf (greger-stream-state-accumulated-output state)
        (concat (greger-stream-state-accumulated-output state) output))

  (greger-stream--process-claude-events state))
</tool.toolu_013wNA7urSdfecLSxvgruB1U>

### git_commit_message

<tool.toolu_013wNA7urSdfecLSxvgruB1U>
Add error handling in greger-stream--process-output-chunk to raise error on API error responses
</tool.toolu_013wNA7urSdfecLSxvgruB1U>

## TOOL RESULT:

ID: toolu_013wNA7urSdfecLSxvgruB1U

<tool.toolu_013wNA7urSdfecLSxvgruB1U>
Successfully replaced content in /Users/andreas/projects/aichat3/greger-stream.el. Successfully staged 1 file(s) and committed with message: Add error handling in greger-stream--process-output-chunk to raise error on API error responses
</tool.toolu_013wNA7urSdfecLSxvgruB1U>

## ASSISTANT:

Perfect! I've modified the `greger-stream--process-output-chunk` function to handle error responses. Here's what the change does:

1. **Error Detection**: The function now checks if the output starts with `{"type":"error"` to identify error responses
2. **JSON Parsing**: It attempts to parse the error JSON to extract the error details
3. **Error Raising**: It raises a descriptive error with the format `"API Error (error_type): error_message"`
4. **Fallback**: If JSON parsing fails, it falls back to showing the raw output as an error

For the example error you provided:
```json
{"type":"error","error":{"type":"invalid_request_error","message":"input length and 'max_tokens' exceed context limit: 142200 + 64000 > 200000, decrease input length or 'max_tokens' and try again"}}
```

This would now raise an error like:
```
API Error (invalid_request_error): input length and 'max_tokens' exceed context limit: 142200 + 64000 > 200000, decrease input length or 'max_tokens' and try again
```

The error handling is wrapped in a `condition-case` to gracefully handle any JSON parsing errors and still provide meaningful feedback to the user.

## USER:

That string-match-p is too rigid. Wrap the error check in a function. First try to read it as json, if it fails to parse as json return with no error. If it parses as json and has `"type": "error"`, raise an error with the message. Otherwise return with no error.

## ASSISTANT:

You're absolutely right. Let me create a more robust error checking function and update the code accordingly.

## TOOL USE:

Name: str-replace
ID: toolu_01LVa146CWEJkfTKCSZ3s5ut

### file_path

<tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>
greger-stream.el
</tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>

### original_content

<tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>
(defun greger-stream--process-output-chunk (output state provider-config)
  "Process a chunk of OUTPUT using STATE."
  ;; Always accumulate for complete response

  ;; Check for error responses and raise an error if found
  (when (string-match-p "^{\"type\":\"error\"" output)
    (condition-case nil
        (let* ((error-data (json-read-from-string output))
               (error-info (alist-get 'error error-data))
               (error-message (alist-get 'message error-info))
               (error-type (alist-get 'type error-info)))
          (error "API Error (%s): %s" error-type error-message))
      (json-error
       (error "API Error: %s" output))))

  (setf (greger-stream-state-complete-response state)
        (concat (greger-stream-state-complete-response state) output))

  ;; Update working buffer for chunk processing
  (setf (greger-stream-state-accumulated-output state)
        (concat (greger-stream-state-accumulated-output state) output))

  (greger-stream--process-claude-events state))
</tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>

### new_content

<tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>
(defun greger-stream--check-for-error (output)
  "Check OUTPUT for error responses and raise an error if found.
Returns nil if no error found or if OUTPUT is not valid JSON."
  (condition-case nil
      (let ((data (json-read-from-string output)))
        (when (string= (alist-get 'type data) "error")
          (let* ((error-info (alist-get 'error data))
                 (error-message (alist-get 'message error-info))
                 (error-type (alist-get 'type error-info)))
            (error "API Error (%s): %s" error-type error-message))))
    (json-error nil)))

(defun greger-stream--process-output-chunk (output state provider-config)
  "Process a chunk of OUTPUT using STATE."
  ;; Check for error responses and raise an error if found
  (greger-stream--check-for-error output)

  ;; Always accumulate for complete response
  (setf (greger-stream-state-complete-response state)
        (concat (greger-stream-state-complete-response state) output))

  ;; Update working buffer for chunk processing
  (setf (greger-stream-state-accumulated-output state)
        (concat (greger-stream-state-accumulated-output state) output))

  (greger-stream--process-claude-events state))
</tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>

### git_commit_message

<tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>
Refactor error checking into separate function with robust JSON parsing
</tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>

## TOOL RESULT:

ID: toolu_01LVa146CWEJkfTKCSZ3s5ut

<tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>
Successfully replaced content in /Users/andreas/projects/aichat3/greger-stream.el. Successfully staged 1 file(s) and committed with message: Refactor error checking into separate function with robust JSON parsing
</tool.toolu_01LVa146CWEJkfTKCSZ3s5ut>

## ASSISTANT:

Perfect! I've refactored the error checking into a separate function `greger-stream--check-for-error` that follows your requirements:

1. **Robust JSON Parsing**: First attempts to parse the output as JSON
2. **Graceful Failure**: If JSON parsing fails, it returns `nil` (no error) and continues normally
3. **Error Detection**: If it successfully parses as JSON and has `"type": "error"`, it raises an error with the message
4. **Clean Return**: Otherwise, it returns `nil` and processing continues normally

The new `greger-stream--check-for-error` function:
- Uses `condition-case` to catch `json-error` exceptions
- Only checks for the error type if JSON parsing succeeds
- Extracts the error type and message for a descriptive error
- Returns `nil` in all non-error cases (including JSON parsing failures)

This approach is much more flexible and won't break on partial JSON chunks or non-JSON output that might come through the stream.

## USER:

I'm getting an error

```
  alist-get(type "type")
  (string= (alist-get 'type data) "error")
  (if (string= (alist-get 'type data) "error") (progn (let* ((error-info (alist-get 'error data)) (error-message (alist-get 'message error-info)) (error-type (alist-get 'type error-info))) (error "API Error (%s): %s" error-type error-message))))
  (let ((data (json-read-from-string output))) (if (string= (alist-get 'type data) "error") (progn (let* ((error-info (alist-get 'error data)) (error-message (alist-get 'message error-info)) (error-type (alist-get 'type error-info))) (error "API Error (%s): %s" error-type error-message)))))
  (condition-case nil (let ((data (json-read-from-string output))) (if (string= (alist-get 'type data) "error") (progn (let* ((error-info (alist-get ... data)) (error-message (alist-get ... error-info)) (error-type (alist-get ... error-info))) (error "API Error (%s): %s" error-type error-message))))) (json-error nil))
  greger-stream--check-for-error("\"type\":\"content_block_delta\",\"index\":1,\"delta\":{\"t...")

```



## ASSISTANT:

I see the issue! The problem is that `json-read-from-string` is expecting a complete JSON object, but we're getting partial JSON chunks in the stream. When `json-read-from-string` encounters incomplete JSON, it might return a string instead of an alist, causing `alist-get` to fail.

Let me fix the function to handle this properly:

## ASSISTANT:



## ASSISTANT:



## TOOL USE:

Name: str-replace
ID: toolu_01Kx4YLUWH3FdovyWhh3dVuj

### file_path

<tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>
greger-stream.el
</tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>

### original_content

<tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>
(defun greger-stream--check-for-error (output)
  "Check OUTPUT for error responses and raise an error if found.
Returns nil if no error found or if OUTPUT is not valid JSON."
  (condition-case nil
      (let ((data (json-read-from-string output)))
        (when (string= (alist-get 'type data) "error")
          (let* ((error-info (alist-get 'error data))
                 (error-message (alist-get 'message error-info))
                 (error-type (alist-get 'type error-info)))
            (error "API Error (%s): %s" error-type error-message))))
    (json-error nil)))
</tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>

### new_content

<tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>
(defun greger-stream--check-for-error (output)
  "Check OUTPUT for error responses and raise an error if found.
Returns nil if no error found or if OUTPUT is not valid JSON."
  (condition-case nil
      (let ((data (json-read-from-string output)))
        (when (and (listp data)
                   (string= (alist-get 'type data) "error"))
          (let* ((error-info (alist-get 'error data))
                 (error-message (alist-get 'message error-info))
                 (error-type (alist-get 'type error-info)))
            (error "API Error (%s): %s" error-type error-message))))
    (error nil)))
</tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>

### git_commit_message

<tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>
Fix error checking to handle partial JSON and non-alist results
</tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>

## TOOL RESULT:

ID: toolu_01Kx4YLUWH3FdovyWhh3dVuj

<tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>
Successfully replaced content in /Users/andreas/projects/aichat3/greger-stream.el. Successfully staged 1 file(s) and committed with message: Fix error checking to handle partial JSON and non-alist results
</tool.toolu_01Kx4YLUWH3FdovyWhh3dVuj>

## ASSISTANT:

I've fixed the function with two key changes:

1. **Added `(listp data)` check**: This ensures that `data` is actually an alist before trying to use `alist-get` on it. When JSON parsing fails or returns something other than an alist (like a string), this will prevent the error.

2. **Changed from `json-error` to `error`**: This catches all types of errors that might occur during JSON parsing or data access, not just JSON parsing errors specifically.

The function now safely handles:
- Incomplete JSON chunks (which won't parse successfully)
- JSON that parses to something other than an alist
- Any other errors that might occur during the process

This should resolve the error you were seeing when processing streaming chunks.

## USER:
